import child_process from "child_process";
import fs from "fs-extra";
import hostile from "hostile";
import open from "open";
import path from "path";
import validURL from "valid-url";
import { chalk } from "../lib/util/chalk.js";
import { description } from "../lib/util/description.js";
import { template } from "../lib/util/template.js";
import { wait } from "../lib/util/wait.js";

function isFunction(val: any): val is Function {
  return val && typeof val === "function";
}

/**
 * Wraps a method that normally has an async callback pattern into a Promise,
 * thus making await patterns possible.
 */
function promisify<T>(context: T, methodName: keyof T, ...args: any[]) {
  return new Promise<any>((resolve, reject) => {
    const method = context[methodName];

    if (!isFunction(method)) {
      reject(new Error(`${String(methodName)} is not a function`));
      return;
    }

    method(...args, (error: Error, value: any) => {
      if (error) {
        console.warn(error);
        reject(error);
        process.exit(1);
      } else {
        resolve(value || void 0);
      }
    });
  });
}

/**
 * This looks at the package.json and modifies the host file to include the
 * hosts specified in the "hosts" property. This will only work if this script
 * was ran as an administrator.
 */
async function configureHosts() {
  // Get the package for the project
  const pkg = fs.readJSONSync(path.resolve("package.json"));
  const hosts = pkg.hosts;

  // No hosts present, means we do not need to do anything in this process.
  if (!hosts) return;

  // Update the hosts file to match the hosts specified in package.json
  const keys = Object.keys(hosts);
  let lines = await promisify(hostile, "get", false);
  const needsHost: [string, string][] = [];

  console.warn(chalk.yellow("Updating hosts file..."));
  for (const key of keys) {
    try {
      // If the host is not present in the config already, add it in
      if (
        !lines.find(
          (l: [string, string]) => l[0] === key && l[1] === hosts[key]
        )
      ) {
        needsHost.push([key, hosts[key]]);
      }
    } catch (err) {
      if (err instanceof Error) console.warn(chalk.red(err.message));
    }
  }

  // Append the hosts to /etc/hosts
  if (needsHost.length > 0) {
    console.warn(
      chalk.yellow(
        "Adding hosts (You may be prompted for administrator password):\n\t",
        needsHost.map((h) => `${h[0]} => ${h[1]}`).join("\n\t")
      )
    );

    child_process.execFileSync(
      "sudo",
      ["echo", "Granted sudo access to update hosts file."],
      { stdio: "inherit" }
    );

    // Last three characters are the permissions
    const chmodBak = child_process
      .execFileSync("stat", ["-f", "%p", "/etc/hosts"])
      .toString();

    // Make the file writeable
    child_process.execFileSync("sudo", ["chmod", "666", "/etc/hosts"], {
      stdio: "inherit",
    });

    for (const host of needsHost) {
      fs.appendFileSync("/etc/hosts", `${host[0]} ${host[1]}`);
    }

    fs.appendFileSync("/etc/hosts", `\n`);

    // Restore the permissions
    child_process.execFileSync(
      "sudo",
      ["chmod", chmodBak.substring(chmodBak.length - 4).trim(), "/etc/hosts"],
      {
        stdio: "inherit",
      }
    );
  }

  await wait(500);

  // After updating the host file, let's ensure all hosts were added.
  console.warn(chalk.yellow("Verifying hosts file..."));
  lines = await promisify(hostile, "get", false);
  let didFail = false;

  needsHost.forEach(([key, value]) => {
    if (
      !lines.find((l: [string, string]) => l[0] === key && l[1] === hosts[key])
    ) {
      didFail = true;
      console.warn(
        chalk.redBright(
          `Failed to add host: ${chalk.yellowBright(
            key
          )} => ${chalk.yellowBright(value)}`
        )
      );
    }
  });

  if (didFail) {
    console.warn(
      chalk.red(description`
        *************************************************************************
        * Some hosts specified in the package.json were not able to be written  *
        * to the hosts file for the system. You can amend this by editing the   *
        * file yourself, or by trying to run this script again as an admin.     *
        *************************************************************************
      `)
    );
  }
}

function openURL(
  urlConfig: Record<string, string>,
  url: string,
  options: Record<string, string | undefined>
) {
  let targetUrl = url;

  if (validURL.isWebUri(url)) {
    targetUrl = url;
  } else if (urlConfig[url]) {
    targetUrl = urlConfig[url];
  }

  // Replace any
  const result = template({
    options,
    template: targetUrl,
  });

  if (result.unresolvedTemplateOptions.size > 0) {
    console.warn(
      chalk.red(
        description`
          You must specify these env variables for this URL to work:
          ${Array.from(result.unresolvedTemplateOptions.keys()).join("\n\t")}
        `
      )
    );
    throw new Error("Missing env configuration for URL");
  }

  targetUrl = result.template;

  if (validURL.isWebUri(targetUrl)) {
    console.warn("Navigating to:", chalk.cyanBrightBold(targetUrl));
    open(targetUrl);
  } else {
    console.warn("Can not open invalid URL:", chalk.redBrightBold(targetUrl));
  }
}

/**
 * This command simply opens a URL via an npm command. The value provided can be
 * a valid URI OR it can be a key for the value found in package.json "url".
 *
 * eg -
 * url: "node bin/main url \"https://figma.com\""
 *
 * or if there is a "figma" entry in the "url" property in package.json -
 * url: "node bin/main url \"figma\""
 */
export default async function run(url?: string | string[], options?: string[]) {
  const pkg = fs.readJSONSync(path.resolve("package.json"));
  const urlConfig: Record<string, string> = pkg?.url || {};
  const optionsConfig: Record<string, string> =
    options?.reduce(
      (p, opt, i) => {
        p[`${i + 1}`] = opt;
        return p;
      },
      {} as Record<string, string>
    ) || {};

  if (!url || url.length <= 0) {
    console.warn(description`
      Available URLs:
        ${chalk.cyanBrightBold(Object.keys(urlConfig).join("\n        "))}
    `);

    return;
  }

  await configureHosts();

  const allOptions = {
    ...process.env,
    ...optionsConfig,
  };

  if (Array.isArray(url)) {
    url.forEach((uri) => {
      openURL(urlConfig, uri, allOptions);
    });
  } else {
    openURL(urlConfig, url, allOptions);
  }
}
