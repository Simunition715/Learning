import * as url from "url";
import fs from "fs";
import inquirer from "inquirer";
import path from "path";
import shell from "shelljs";
import { chalk } from "../lib/util/chalk.js";
import { fuzzySource } from "../lib/util/fuzzy-source.js";
import { paramCase, pascalCase } from "change-case";

const __dirname = url.fileURLToPath(new URL(".", import.meta.url));

type Paths = {
  componentsPath: string;
  storiesComponents: string;
  storiesData: string;
};

/**
 * Recursively find all components in a directory.
 * Returns only the component that matches the name of the directory
 */
function getAllComponents(dirPath: string, out?: string[]) {
  const files = fs.readdirSync(dirPath);
  let arrayOfFiles = out || [];

  files.forEach(function (file) {
    if (fs.statSync(`${dirPath}/${file}`).isDirectory()) {
      arrayOfFiles = getAllComponents(`${dirPath}/${file}`, arrayOfFiles);
    } else {
      // checks if the file is a component file in paramCase and that the
      // component name matches the folder name
      if (
        /\w+(-\w+)*\.tsx/.test(file) &&
        file.split(".")[0] === path.basename(dirPath)
      ) {
        arrayOfFiles.push(path.join(__dirname, dirPath, "/", file));
      }
    }
  });

  return arrayOfFiles;
}

/**
 * Ensure this project matches the requirements for deleting a component.
 */
async function checkStructure(): Promise<Paths> {
  const componentsPath = path.resolve("ui/components");
  const storiesPath = path.resolve("ui/stories");
  const storiesComponents = path.resolve(storiesPath, "components");
  const storiesData = path.resolve(storiesPath, "data");
  let fail = "";

  if (
    !fs.existsSync(componentsPath) ||
    !fs.statSync(componentsPath).isDirectory()
  ) {
    fail += `${componentsPath} not found or is not a directory\n`;
  }

  if (!fs.existsSync(storiesPath) || !fs.statSync(storiesPath).isDirectory()) {
    fail += `${storiesPath} not found or is not a directory\n`;
  }

  if (
    !fs.existsSync(storiesComponents) ||
    !fs.statSync(storiesComponents).isDirectory()
  ) {
    fail += `${storiesComponents} not found or is not a directory\n`;
  }

  if (!fs.existsSync(storiesData) || !fs.statSync(storiesData).isDirectory()) {
    fail += `${storiesData} not found or is not a directory\n`;
  }

  if (fail) {
    console.warn(fail);
    process.exit(1);
  }

  const out: Paths = {
    componentsPath,
    storiesComponents,
    storiesData,
  };

  return out;
}

/**
 * This prompts the user for the component name and directory of choice.
 */
async function requestName(paths: Paths, name: string) {
  // If the name of the desired component was not provided, let's provide an
  // automated curated list to pick from
  const allComponents = getAllComponents(paths.componentsPath);

  if (!name) {
    const checkFiles = new Set<string>();
    allComponents.forEach((f) =>
      checkFiles.add(path.basename(f).split(".").slice(0, -1).join("."))
    );

    const { selectedName } = await inquirer.prompt<{ selectedName: string }>([
      {
        type: "autocomplete",
        name: "selectedName",
        message: "Find a component to delete:",
        suggestOnly: false,
        source: fuzzySource(checkFiles),
      },
    ]);

    name = selectedName;
  }

  name = pascalCase(
    name
      .split(" ")
      .map((s) => pascalCase(s))
      .join("")
  );

  // Search for this component name within the components folder to find
  // component with matching name
  const checkFiles = new Map();
  allComponents.forEach((f) => checkFiles.set(path.basename(f), f));
  const componentPath =
    checkFiles.get(`${name}.tsx`) || checkFiles.get(`${paramCase(name)}.tsx`);
  let selectedDirectoryName = "";

  // See if we have a match with a component name
  if (componentPath) {
    selectedDirectoryName = path.basename(
      path.dirname(path.dirname(componentPath))
    );
  } else {
    console.warn(
      `Unable to find a component with name ${name}.tsx or ${paramCase(
        name
      )}.tsx`
    );
    process.exit(0);
  }

  return {
    directoryName: selectedDirectoryName,
    name,
    fileName: name
      .split(" ")
      .map((s) => `${paramCase(s)}`)
      .join(""),
  };
}

/**
 * Returns an array of file paths to delete for a given component and directory.
 * @param {Paths} param0 - An object containing the file paths for components, stories, and data.
 * @param {string} directory - The name of the directory containing the component.
 * @param {string} fileName - The base name of the component.
 * @returns {string[]} Array of file paths to delete.
 */
function getFilesToDelete(
  { componentsPath, storiesComponents, storiesData }: Paths,
  directory: string,
  fileName: string
) {
  // Create an array of file paths to delete.
  const filesToDelete = [
    path.resolve(componentsPath, directory, fileName, `${fileName}.tsx`),
    path.resolve(componentsPath, directory, fileName, `${fileName}.types.ts`),
    path.resolve(componentsPath, directory, fileName, `${fileName}.scss`),
    path.resolve(storiesComponents, directory, `${fileName}.stories.tsx`),
    path.resolve(storiesData, directory, `${fileName}-props.tsx`),
  ].filter((file) => {
    // Filter out files that don't exist
    try {
      fs.accessSync(file, fs.constants.F_OK);
      return true;
    } catch {
      return false;
    }
  });

  // Return the array of file paths to delete.
  return filesToDelete;
}

/**
 * Deletes all files in the specified paths array.
 * @param files - An array of file paths to delete.
 */
function deleteFiles(files: string[]) {
  // Loop through each file path in the array
  if (shell.exec(`trash ${files.join(" ")}`).code !== 0) {
    console.warn(
      chalk.red(`Error: Something went wrong trying to delete these files.`)
    );
    process.exit(1);
  } else {
    console.warn(`\n`);
    console.warn(chalk.green(`Successfully moved all files to trash bin.`));
  }
}
/**
 * Deletes all empty folders in the specified paths array.
 * @param paths - An array of folder paths to check.
 */
function deleteEmptyFolders(paths: string[], projectPath: string) {
  // Loop through each folder path in the array
  paths.forEach((folder) => {
    try {
      // Get the stats for the folder
      const stats = fs.statSync(folder);

      // Check if the folder is a directory
      if (stats.isDirectory()) {
        // Get the contents of the folder
        const contents = fs.readdirSync(folder);

        // If the folder is empty, delete it
        if (contents.length === 0) {
          fs.rmdirSync(folder);
          console.warn(
            chalk.green(`Deleted folder: `) +
              chalk.cyan(`${path.relative(projectPath, folder)}/`)
          );
        } else {
          // Otherwise, log a warning that the folder is not empty and skip deletion
          // And print remaining fragments
          console.warn(
            chalk.yellow(`Folder deletion skipped -`),
            `${chalk.cyan(`${path.relative(projectPath, folder)}/`)}`,
            chalk.yellow(`is not empty`)
          );
          console.warn(chalk.yellow(`Remaining fragments found:`));
          console.warn(contents.map((content) => `=> ${content}`).join("\n"));
        }
      }
    } catch {
      // If an error occurs (e.g. folder doesn't exist), add an error message to the errors string
      console.error(chalk.red(`Unable to locate:\n${folder}\n`));
    }
  });
}

/**
 * Removes a component export statement from a TypeScript barrel file.
 *
 * @param subFolder - The sub-folder to look for the barrel file and component.
 * @param componentName - The name of the component to remove from the barrel file.
 * @returns - Nothing. Throws an error if the barrel file or component file cannot be read, or if the component cannot be removed from the barrel file.
 */
function removeComponentFromBarrel(
  subFolder: string,
  componentName: string
): void {
  // Resolve the paths to the index file and component file.
  const indexFilePath = path.resolve(subFolder, "index.ts");
  const componentPath = path.resolve(
    subFolder,
    componentName,
    `${componentName}.tsx`
  );
  // Check if the component file exists.
  const exists = fs.existsSync(componentPath);

  if (!exists) {
    console.error(`${componentName} does not exist in ${subFolder} sub-folder`);
    process.exit(1);
  }

  // Remove the line from the index file if the path reference after 'from' exists.
  try {
    // Read the contents of the index file.
    const indexFileContents = fs.readFileSync(indexFilePath, "utf8");
    // Split the contents of the index file into an array of lines.
    // \r, \n, and \r\n
    let lines = indexFileContents.split("\r\n");
    if (lines.length === 1) lines = indexFileContents.split("\r");
    if (lines.length === 1) lines = indexFileContents.split("\n");

    // Filter out the line that imports the component being removed.
    const updatedLines = lines.filter((line) => {
      // Use a regular expression to match the import statement.
      line = line.trim();
      const regex = new RegExp(
        `export \\* from ['"\\\`]\\.\\/${componentName}\\/${componentName}['"\\\`];?`
      );

      return !regex.test(line);
    });

    // Join the lines back together into a string and write it to the index file.
    const updatedIndexFileContents = updatedLines.join("\n");
    fs.writeFileSync(indexFilePath, updatedIndexFileContents, "utf8");
  } catch (err) {
    if (err instanceof Error) {
      console.error(
        chalk.red(
          `Error removing ${componentName} export from ${subFolder}/index.ts`,
          err.stack || err.message
        )
      );
    }
  }
}

async function confirmDeletePrompt(
  filesToDelete: string[],
  fileName: string,
  projectPath: string
) {
  const { shouldDelete } = await inquirer.prompt<{
    shouldDelete: boolean;
  }>([
    {
      type: "confirm",
      name: "shouldDelete",
      default: false,
      message: `
${chalk.yellow("Attempting to delete:\n")}
${filesToDelete.map((file) => `${path.relative(projectPath, file)}`).join("\n")}

${chalk.red(`Delete \`${fileName}\` component and all associated files?`)}
      `.trim(),
    },
  ]);

  return shouldDelete;
}

export default async function run(name: string, ..._args: any[]) {
  const projectPath = path.resolve();
  // Validate the project structure and provide the paths that have been
  // determined valid.
  const paths = await checkStructure();

  // Requests the directory and the component name from the user
  const { directoryName, fileName } = await requestName(paths, name);
  const filesToDelete = getFilesToDelete(paths, directoryName, fileName);
  const foldersToDelete = [
    path.resolve(paths.componentsPath, directoryName, fileName),
  ];
  const confirmDelete = await confirmDeletePrompt(
    filesToDelete,
    fileName,
    projectPath
  );

  if (!confirmDelete) {
    console.warn(chalk.yellow("Delete cancelled."));
    process.exit(0);
  }

  removeComponentFromBarrel(
    path.resolve(paths.componentsPath, directoryName),
    fileName
  );
  await deleteFiles(filesToDelete);
  deleteEmptyFolders(foldersToDelete, projectPath);
}
