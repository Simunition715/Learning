import fs from "fs-extra";
import path from "path";
import shell from "shelljs";
import { gitEnsureRemote } from "../lib/git/git-ensure-remote.js";
import { gitHasChanges } from "../lib/git/git-has-changes.js";
import { gitReturnToDev } from "../lib/git/git-return-to-dev.js";
import { npmRun } from "../lib/util/npm-run.js";
import { promptConfirm } from "../lib/prompt/prompt-confirm.js";
import { targetProjectPackage } from "../lib/target-project/target-project-package.js";

/**
 * This method checks all of the package json settings and ensures the
 * repositories listed are valid for use within this context.
 */
async function validateRepository() {
  // Make sure there is an accessible origin remote
  await gitEnsureRemote("origin");
  // Make sure there is an accessible heroku remote
  await gitEnsureRemote("heroku");

  // We can only do this operation if there is nothing to commit or push
  // This only works if no changes are present
  if (await gitHasChanges()) {
    console.error(`
      You have uncommitted changes or the current state of the project can not
      be determined. Please commit or stash them before continuing.
    `);
    process.exit(1);
  }

  // Ask if the view-release script looks good and should continue
  const shouldContinue = await promptConfirm(`
    Initial checks for the project have been completed. Should the release
    continue being made?
  `);

  // Quit the process if the view release did not work
  if (!shouldContinue) process.exit(1);
}

/**
 * Makes sure we are on the storybook branch and completely updated with the
 * contents of dev.
 */
async function checkoutStorybookBranch() {
  // Make sure we're on a release branch that matches dev
  if (shell.exec("git checkout storybook").code !== 0) {
    if (shell.exec("git checkout -b storybook").code !== 0) {
      console.warn(
        "Could not switch to the storybook branch. Make sure the branch exists locally."
      );
      process.exit(1);
    }
  }

  // Make sure we have the latest from the remote
  if (shell.exec("git fetch origin").code !== 0) {
    console.warn("Could not fetch from remote servers.");
    process.exit(1);
  }

  // Make sure we are exactly what is in dev
  if (shell.exec(`git reset --hard origin/dev`).code !== 0) {
    console.warn(`Could not reset branch to dev`);
    process.exit(1);
  }
}

async function buildStorybook() {
  // Create the static files
  if (!npmRun("storybook", ["build"])) {
    console.warn("Could not build storybook.");
    process.exit(1);
  }

  // Rename the static file folder to storybook-heroku so it won't be ignored by
  // the gitignore file.
  fs.moveSync("storybook-static", "storybook-heroku", { overwrite: true });
}

async function adjustConfig() {
  // Ensure the ProcFile exists
  if (!fs.existsSync("Procfile")) {
    // Add the procfile with npm start
    fs.writeFileSync(path.resolve("Procfile"), "web: npm start");
  }

  // TODO: starybook static build is not working correctly, so as a workaround
  // we are going to just make the heroku node run a dev server.
  // Ensure the package json has the correct start script
  const packageJson = await targetProjectPackage();
  // Run the devops command entry point directly as heroku seems to delete the
  // .bin folder in node_modules.
  const startCommand = "http-server ./storybook-heroku";

  if (packageJson?.scripts?.start !== startCommand) {
    packageJson.scripts = packageJson.scripts || {};
    packageJson.scripts.start = startCommand;
  }
  // If http-server is in devdeps, that's an error
  if (packageJson?.devDependencies?.["http-server"]) {
    console.error(`
      You have http-server in your devDependencies. This is not allowed as it
      will not be available in the heroku environment. Please move it to
      dependencies.
    `);
    process.exit(1);
  }

  // Ensure http-server is included as a dependency
  if (!packageJson?.dependencies?.["http-server"]) {
    npmRun("i", ["-E", "http-server"]);
  }

  // TODO: Continuing our workaround:
  // We copy all dev-deps to dependencies so heroku doesn't nuke anything
  // important
  packageJson.dependencies = packageJson.dependencies || {};
  Object.assign(packageJson.dependencies, packageJson.devDependencies);
  packageJson.devDependencies = {};

  // Write the package
  fs.writeFileSync(
    path.resolve("package.json"),
    JSON.stringify(packageJson, null, 2)
  );
}

async function pushToHeroku() {
  // Add and commit all fragments
  if (shell.exec("git add -A").code !== 0) {
    console.warn("Could not add all files to commit.");
    process.exit(1);
  }

  // Commit the changes
  if (shell.exec("git commit -m 'Storybook Release'").code !== 0) {
    console.warn("Could not commit changes.");
    process.exit(1);
  }

  // Push the changes
  if (shell.exec("git push -f heroku storybook:master").code !== 0) {
    console.warn("Could not push changes to heroku.");
    process.exit(1);
  }
}

export default async function run() {
  await validateRepository();
  await checkoutStorybookBranch();
  await buildStorybook();
  await adjustConfig();
  await pushToHeroku();
  await gitReturnToDev();
}
