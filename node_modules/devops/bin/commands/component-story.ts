// import findComponent from "../lib/component/find-component.js";
// import fs from "fs-extra";
// import path from "path";
// import { caseTransformTokens } from "../lib/template/case-transform-tokens.js";
// import {
//   checkComponentStructure,
//   Paths,
// } from "../lib/component/check-component-structure.js";
// import { description } from "../lib/util/description.js";
// import { getAllComponents } from "../lib/component/get-all-components.js";
// import { getComponentPaths } from "../lib/component/get-component-paths.js";
// import { getTemplateFile } from "../lib/template/get-template-file.js";
// import { pascalCase } from "change-case";
// import { promptSelect } from "../lib/prompt/prompt-select.js";
// import { promptTextInput } from "../lib/prompt/prompt-text-input.js";

// /**
//  * This prompts the user for the component name and directory of choice.
//  */
// async function requestName(paths: Paths, name: string) {
//   // If the name of the desired component was not provided, let's provide an
//   // automated curated list to pick from
//   if (!name) {
//     const allFiles = await getAllComponents(paths);
//     const checkFiles = new Set<string>();
//     allFiles.forEach((f) =>
//       checkFiles.add(path.basename(f).split(".").slice(0, -1).join("."))
//     );

//     name =
//       (await promptSelect(
//         "Type a name for the component:",
//         Array.from(checkFiles.values())
//       )) || "";
//   }

//   return findComponent(name, paths);
// }

// enum BlockType {
//   Comment,
//   String,
//   Code,
// }

// /**
//  * This is a method that detects a specified code block and injects code at the
//  * start or end of the block. This is primarily good for finding class and
//  * function definitions in a file.
//  */
// async function injectIntoBlock(
//   str: string,
//   tokens: (string | { optional: string[] })[],
//   injectAtStart: string,
//   injectAtEnd: string
// ) {
//   // We now must count valid context brackets till we find a bracket that would close the context of the main
//   // body.
//   let insideMultilineComment = false;
//   let insideSingleLineComment = false;
//   let insideTemplate = false;
//   let insideTemplateCodeBlock = false;
//   let insideDoubleQuote = false;
//   let insideSingleQuote = false;

//   // Stores every block discovered while parsing the file. We track valid code
//   // definition blocks vs non-code (comments, strings). This stores all the
//   // blocks in the order they are discovered. Looping through this list and
//   // generating a string based off all indices will re-generate the entire file.
//   // You can skip comment blocks and get the entire file without comments using
//   // this. Do not skip string blocks ever as strings are required for a program
//   // to operate.
//   const blocks: { start: number; end: number; type: BlockType }[] = [];
//   // When we start a new block, we will have an associated state with it to keep
//   // track of contexts we pass through so we can establish things like when that
//   // context is closed.
//   const blockState: { block: (typeof blocks)[number]; openBracket: number }[] =
//     [];

//   // Begins a new block that was discovered. It will be created in an open state
//   // with it's end set to -1
//   const newBlock = (start: number, type: BlockType) => {
//     const block = { start, end: -1, type };
//     blocks.push(block);
//     blockState.push({ block, openBracket: 0 });
//   };

//   // Gets the current block state we are currently within
//   const getState = () => {
//     return blockState[blockState.length - 1];
//   };

//   // Closes the current block we are within and pops the block state to the
//   // previous block being processed.
//   const closeBlock = (end: number) => {
//     const state = getState();
//     state.block.end = end;
//     blockState.pop();
//   };

//   // Find the beginning of the Store definition
//   // Use this regex to find the beginning of the main method up to it's
//   // opening bracket.
//   const found = str.match(
//     /class(((.+)(\s*))|(\s*))(Store(\s+)|Store|Store(((.+)(\s*))|(\s*))extends(((.+)(\s*))|(\s*)))(((.+)(\s*)\{)|(\s*)\{)/gm
//   );

//   if (!found || found.length <= 0) {
//     console.warn(description`
//       Could not establish the location of the Store class definition in the
//       props file. This operation will not modify the file. Please ensure the
//       file follows the standard format with:

//       class Store extends IProps {

//       Where this object is the props to be passed to the story args.
//     `);
//     return;
//   }

//   const insideString = () => {
//     return insideDoubleQuote || insideSingleQuote || insideTemplate;
//   };

//   // When openBracket === close bracket, we have the location of the end of the body of the main method
//   for (let i = 0, iMax = str.length; i < iMax; ++i) {
//     const char = str[i];
//     const nextChar = str[i + 1];

//     // Analyze each character for comments and valid bracket contexts
//     switch (char) {
//       // Skip over escape characters
//       case "\\":
//         if (insideString()) i++;
//         break;
//       case "/":
//         // Ignore any comment start characters when we're in a string.
//         if (insideString()) break;
//         switch (nextChar) {
//           case "*":
//             if (!insideSingleLineComment && !insideMultilineComment) {
//               insideMultilineComment = true;
//               newBlock(i, BlockType.Comment);
//               i++;
//             }
//             break;

//           case "/":
//             if (!insideMultilineComment && !insideSingleLineComment) {
//               insideSingleLineComment = true;
//               newBlock(i, BlockType.Comment);
//               i++;
//             }
//             break;
//         }
//         break;

//       case "*":
//         // We only care about stars when inside multiline comments
//         if (!insideMultilineComment) break;
//         if (nextChar === "/") {
//           insideMultilineComment = false;
//           i++;
//           closeBlock(i + 1);
//         }
//         break;

//       case "\n":
//       case "\r":
//         if (insideString()) break;
//         if (insideSingleLineComment) {
//           insideSingleLineComment = false;
//           closeBlock(i + 1);
//         }
//         break;

//       case "$":
//         // Only care about $ characters when inside a template string
//         if (!insideTemplate) break;

//         // If inside a template a ${ indicates a break into a code block
//         if (nextChar === "{") {
//           i++;
//           insideTemplate = false;
//           insideTemplateCodeBlock = true;
//           closeBlock(i);
//         }
//         break;

//       case "}":
//         break;

//       case "`":
//         break;

//       case '"':
//         if (
//           insideSingleLineComment ||
//           insideMultilineComment ||
//           insideTemplate
//         ) {
//           break;
//         }
//         if (insideString()) {
//           if (insideDoubleQuote) {
//             insideDoubleQuote = false;
//             closeBlock(i + 1);
//           }
//         } else {
//           insideDoubleQuote = true;
//           newBlock(i, BlockType.String);
//         }
//         break;

//       case "'":
//         if (insideSingleLineComment || insideMultilineComment) break;
//         if (insideString()) {
//           if (insideSingleQuote) {
//             insideSingleQuote = false;
//             closeBlock(i + 1);
//           }
//         } else {
//           insideSingleQuote = true;
//           newBlock(i, BlockType.String);
//         }
//         break;
//     }
//   }

//   return str;
// }

// /**
//  * This simply appends the story template to the story file replacing any names
//  * with the new name.
//  */
// async function editStoryFile(
//   filePath: string,
//   componentName: string,
//   newName: string
// ) {
//   if (!fs.existsSync(filePath)) return;

//   // Generate the templated content we will add to the file
//   const options = {
//     component: componentName,
//     name: newName,
//   };

//   const result = caseTransformTokens(
//     options,
//     getTemplateFile("new-story", "story.template") ?? ""
//   );

//   // Read the contents of the story file we are going to edit
//   let data = fs.readFileSync(filePath, "utf8");
//   // Append the new templated data to the file
//   data += `\n${result.template}\n`;
//   // Write our file to the disk
//   fs.writeFileSync(filePath, data, "utf8");
// }

// /**
//  * This takes the contents of the prop template file and adds them to the
//  * structure of the Store within the props file. This requires a standard store
//  * object to be located in the file first.
//  */
// async function editPropFile(
//   filePath: string,
//   _componentName: string,
//   _newName: string
// ) {
//   if (!fs.existsSync(filePath)) return;
// }

// /**
//  * Asks the user for the name of the story and normalizes the name to a case
//  * that can be case transformed without issue.
//  */
// async function getNewStoryName() {
//   let name = await promptTextInput("Type a name for the new story:");

//   name = pascalCase(
//     name
//       .split(" ")
//       .map((s) => pascalCase(s))
//       .join("")
//   );

//   return name;
// }

// /**
//  * The goal of this command is to find the base story file for a component and
//  * append a new story inside the file and append a new Store action for the
//  * story in the props data file.
//  */
export default async function run(_componentName: string) {
  //   // Validate the project structure and provide the paths that have been
  //   // determined valid.
  //   const paths = await checkComponentStructure();
  //   // Requests the directory and the component name from the user
  //   const selection = await requestName(paths, componentName);
  //   // Get all of the paths to the component's files
  //   const allPaths = getComponentPaths(paths, selection);
  //   // Ask the user for the name of the story to add
  //   const newName = await getNewStoryName();
  //   // Modify each file
  //   editStoryFile(allPaths.stories[0], newName);
  //   editPropFile(allPaths.props[0], newName);
}
