import changecase from "change-case";
import fs from "fs-extra";
import path from "path";
import prompt from "inquirer";
import shell from "shelljs";
import url from "url";
import { chalk } from "../lib/util/chalk.js";
import { description } from "../lib/util/description.js";
import { FileDiff, filesDiff } from "../lib/file-management/files-diff.js";
import { promptConfirm } from "../lib/prompt/prompt-confirm.js";
import { promptSelect } from "../lib/prompt/prompt-select.js";
import { promptTextInput } from "../lib/prompt/prompt-text-input.js";
import { SkeletonRC, SkeletonRCSchema } from "./skeleton.js";
import { template } from "../lib/util/template.js";

function isDefined<T>(value?: T | null): value is T {
  return value !== void 0 && value !== null;
}

const __dirname = url.fileURLToPath(new URL(".", import.meta.url));

export enum MigratePrefix {
  INCLUDE = "include",
  DEPRECATE = "deprecrate",
}

/**
 * This method flattens a JSON object into a list of [path[], value] pairs.
 */
function flattenJSON(obj: any) {
  const results: [(string | number)[], any][] = [];

  function recurse(obj: object, path: (string | number)[] = []) {
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; i++) {
        const newPath = [...path, i];
        recurse(obj[i], newPath);
      }
    } else if (typeof obj === "object") {
      for (const [key, value] of Object.entries(obj)) {
        const newPath = [...path, key];
        recurse(value, newPath);
      }
    } else {
      results.push([path, obj]);
    }
  }

  recurse(obj);
  return results;
}

/**
 * Inject a value into a JSON object
 */
function applyJSONValue(obj: any, path: (string | number)[], value: any) {
  const key = path[0];
  if (path.length === 1) {
    obj[key] = value;
  } else {
    if (obj[key] === void 0) {
      obj[key] = typeof path[1] === "number" ? [] : {};
    }
    applyJSONValue(obj[key], path.slice(1), value);
  }
}

/**
 * Delete a property at the targetted path in the JSON object
 */
function deleteJSONValue(obj: any, path: (string | number)[]) {
  const key = path[0];
  if (path.length === 1) {
    delete obj[key];
  } else {
    if (obj[key] === void 0) {
      return;
    }
    deleteJSONValue(obj[key], path.slice(1));
  }
}

/**
 * Retrieve a value from a JSON object
 */
function getJSONValue(obj: any, path: (string | number)[]): any {
  const key = path[0];
  if (path.length === 1) {
    return obj[key];
  } else {
    if (obj[key] === void 0) {
      return void 0;
    }
    return getJSONValue(obj[key], path.slice(1));
  }
}

/**
 * Perform copy of file or directory
 */
function copy(src: string, dest: string) {
  // If it's a file copy the file
  if (fs.statSync(src).isFile()) {
    fs.copyFileSync(src, dest);
  }

  // If it's a directory copy the entire directory
  else {
    fs.copySync(src, dest);
  }
}

/**
 * Provides an override prompt with some choices how to perform the copy.
 */
async function promptOverride(src: string, dest: string, message?: string) {
  const fileName = path.basename(dest);
  const isFiles = fs.statSync(src).isFile() && fs.statSync(dest).isFile();

  console.warn("\n\n");
  const override = await promptSelect(
    message ||
      description`
      Change detected
        file: ${chalk.cyanBrightBold(fileName)}
        path: ${chalk.cyanBrightBold(path.dirname(dest))}
      What would you like to do?
    `,
    [
      "Override",
      isFiles ? "Run diff" : void 0,
      `Create ${fileName}.copy`,
      "Skip",
    ].filter(isDefined)
  );

  switch (override) {
    case "Override":
      copy(src, dest);
      break;

    case "Run diff":
      shell.exec(`code --diff ${src} ${dest}`);
      break;

    case `Create ${fileName}.copy`:
      copy(src, `${dest}.copy`);
      break;

    case "Skip":
    default:
      console.warn(`Skipping ${fileName} file creation.`);
      break;
  }
}

/**
 * Prompt the user to delete a file or directory
 */
async function promptDelete(src: string, message?: string) {
  const fileName = path.basename(src);
  const isFiles = fs.statSync(src).isFile();

  // If the file does not exist locally
  if (!isFiles) {
    return;
  }

  console.warn("\n\n");
  const confirmDelete = await promptConfirm(
    message ||
      description`
      The following file is deprecated
        file: ${chalk.cyanBrightBold(fileName)}
        path: ${chalk.cyanBrightBold(path.dirname(src))}
      Delete this file?
    `
  );

  if (confirmDelete) {
    fs.removeSync(src);
  }
}

/**
 * Compares the contents of two files and returns true if they are the same.
 */
async function compareFiles(file1: string, file2: string) {
  try {
    const f1Exists = fs.existsSync(file1);
    const f2Exists = fs.existsSync(file2);

    // If one exists and the other does not, they are not the same
    if (f1Exists !== f2Exists) return false;

    const f1IsDir = f1Exists && fs.statSync(file1).isDirectory();
    const f2IsDir = f2Exists && fs.statSync(file2).isDirectory();

    // If file type is different, they are not the same
    if (f1IsDir !== f2IsDir) return false;

    // If both are a directory, we need to recursively compare all internal
    // files
    if (f1IsDir && f2IsDir) {
      const files1 = fs.readdirSync(file1).sort();
      const files2 = fs.readdirSync(file2).sort();

      // If the number of files is different, they are not the same
      if (files1.length !== files2.length) return false;

      // If any of the files are different, they are not the same
      for (let i = 0; i < files1.length; i++) {
        const f1 = files1[i];
        const f2 = files2[i];

        if (
          !(await compareFiles(
            path.resolve(file1, f1),
            path.resolve(file2, f2)
          ))
        ) {
          return false;
        }
      }

      return true;
    }

    // Both are files, compare the contents
    else {
      const data1 = fs.readFileSync(file1, "utf8");
      const data2 = fs.readFileSync(file2, "utf8");
      return data1 === data2;
    }
  } catch (err) {
    console.error("Error comparing files:", err);
    return false;
  }
}

/**
 * Detects if a string has unanswered tokens within it.
 */
function hasUnansweredTokens(
  script: string,
  answeredTokens: Record<string, string>
) {
  const contents = script;
  let hasUnanswered = false;

  // Get the tokens from the script
  template({
    template: contents,
    doubleCurlyBrackets: true,
    options: {},

    onToken: (match, _replace) => {
      // The option key name will always be on the side of the colon which
      // delineates transformations of the term.
      const splits = match.split(":").map((x) => x.trim());
      const token = splits[0];

      if (!isDefined(answeredTokens[token])) {
        hasUnanswered = true;
      }

      return match;
    },
  });

  return hasUnanswered;
}

/**
 * Analyzes a script string to see if there are unanswered tokens in it. If all
 * tokens are answered this returns the script with tokens replaced. Otherwise,
 * it returns the original string.
 */
function injectWhenAllAnswered(
  script: string,
  answeredTokens: Record<string, string>
) {
  if (hasUnansweredTokens(script, answeredTokens)) return script;
  return injectAnswers(script, answeredTokens);
}

/**
 * Injects the available answered tokens into the provided script and returns
 * the new string.
 */
function injectAnswers(script: string, answeredTokens: Record<string, string>) {
  // Replace the tokens with the answers provided
  const results = template({
    template: script,
    doubleCurlyBrackets: true,
    // Inject the mapped template options with the answers
    options: answeredTokens,

    onToken: (match, _replace) => {
      match = match.trim();

      if (match in answeredTokens) {
        return answeredTokens[match];
      }

      const checks = match.split(":").map((s) => s.trim());

      if (checks[0] in answeredTokens) {
        let result: string = answeredTokens[checks[0]] || "";

        // Look for a transform to the case
        switch (checks[1]) {
          case "upper":
            result = changecase.capitalCase(result);
            break;
          case "lower":
            result = result.toLowerCase();
            break;
          case "camel":
            result = changecase.camelCase(result);
            break;
          // case "title": result = changecase.titleCase(result); break;
          case "pascal":
            result = changecase.pascalCase(result);
            break;
          case "constant":
            result = changecase.constantCase(result);
            break;
          case "sentence":
            result = changecase.sentenceCase(result);
            break;
          case "header":
            result = changecase.headerCase(result);
            break;
          case "snake":
            result = changecase.snakeCase(result);
            break;

          case "kebab":
          case "param":
            result = changecase.paramCase(result);
            break;

          default:
            result = changecase.capitalCase(result);
            break;
        }

        return result;
      }

      return match;
    },
  });

  return results.template.trim();
}

/**
 * Analyzes a value for tokens to replace and prompts the user for the tokens
 * indicated if an answer for the token is not available already.
 */
async function injectTokens(
  script: string,
  answeredTokens: Record<string, string>,
  tokensRc: Record<string, { description: string }>
) {
  const contents = script;
  const tokens: string[] = [];

  // Get the tokens from the script
  template({
    template: contents,
    doubleCurlyBrackets: true,
    options: {},

    onToken: (match, _replace) => {
      // The option key name will always be on the side of the colon which
      // delineates transformations of the term.
      const splits = match.split(":").map((x) => x.trim());
      tokens.push(splits[0]);
      return match;
    },
  });

  const tokenToQuestion = (token: string) => {
    if (isDefined(answeredTokens[token])) return;
    // Add the token to answered map to prevent duplicate prompts
    answeredTokens[token] = "";

    return {
      type: "input",
      name: token,
      message: tokensRc[token]?.description || `Enter a value for ${token}:`,
    };
  };

  // Prompt for any tokens we don't already have an answer for
  const questions = tokens.map(tokenToQuestion).filter(isDefined);

  let answers: Record<string, string> = {};

  if (questions.length > 0) {
    answers = await prompt.prompt<Record<string, string>>(questions);
  }

  // Store the prompt results in the answered token map
  for (const [key, value] of Object.entries(answers)) {
    answeredTokens[key] = value;
  }

  return injectAnswers(script, answeredTokens);
}

async function migrateInclude(src: string, dest: string) {
  if (!(await compareFiles(src, dest))) {
    // If the file doesn't exist, copy it without prompt
    if (!fs.existsSync(dest)) {
      copy(src, dest);
    }

    // If the file/directory does exit already in the target, we will perform
    // a diff of the files and perform prompts when appropriate.
    else {
      // The diffs computed are the actions necessary to bring the two
      // directories in sync.
      const diffs = await filesDiff(src, dest);

      for (const diff of diffs) {
        const [diffSrc, diffDest, diffType] = diff;

        switch (diffType) {
          // We ignore deletions as we don't care if a target project has
          // added functionality of their own.
          case FileDiff.DELETE:
            // If the source exists, this means it is trying to switch the
            // target to a new file type
            if (fs.existsSync(diffSrc)) {
              const doDelete = await promptConfirm(
                description`A file/folder at ${chalk.cyanBrightBold(
                  diffDest
                )} has changed type and will cause the target file or folder to be overwritten. Continue?`
              );

              if (doDelete) {
                fs.removeSync(diffDest);
              }
            }

            // Otherwise, this is just a delete and should be bypassed as we
            // don't care what the target folders contain.
            else {
              // NOOP
            }
            break;

          // If a file change is detected, just make it happen
          case FileDiff.CHANGE:
            await promptOverride(diffSrc, diffDest);
            break;

          // If a file is new, copy the file without prompt
          case FileDiff.NEW:
            // If the target exists, this is coming from a file type change
            // and the user did NOT want the change to happen. So we ignore
            // this scenario.
            if (fs.existsSync(diffDest)) {
              // NOOP
            }

            // Otherwise, this is a new file and should be copied without
            // question
            else {
              copy(diffSrc, diffDest);
              console.warn(`Created: ${chalk.cyanBrightBold(diffDest)}`);
            }
            break;
        }
      }
    }
  }
}

async function migrateDeprecate(src: string) {
  if (fs.existsSync(src)) {
    await promptDelete(src);
  }
}

async function migrateFiles() {
  // Copy all files from the config directory to the root of the target project.
  // This will also remove the "config" prefex added to each name of thr file.
  const configPath = path.resolve(__dirname, "../../migrate");

  for (const file of fs.readdirSync(configPath)) {
    const src = path.resolve(configPath, file);

    // Get the prefix, everything up to the first period
    const prefix = file.match(/^[^.]+/)?.[0];

    // Get destination file
    const dest = path.resolve(`./${file.replace(`${prefix}.`, "")}`);

    // If the files are different, try to copy the file
    // if prefix is a migrateFunction, then run it
    if (prefix) {
      switch (prefix.toLowerCase().trim()) {
        case MigratePrefix.INCLUDE:
          await migrateInclude(src, dest);
          break;

        case MigratePrefix.DEPRECATE:
          await migrateDeprecate(dest);
          break;

        default:
          // Ignore if prefix undefined
          break;
      }
    }
  }

  const toolsSrc = path.resolve(__dirname, "../../tools");
  const toolsDest = path.resolve(`./tools`);

  if (!(await compareFiles(toolsSrc, toolsDest))) {
    // Ask if tools should be included
    const tools = await promptConfirm(
      "Would you like to install the additional tools folder?",
      false
    );

    // Copy the tools folder if requested
    if (tools) {
      if (!(await compareFiles(toolsSrc, toolsDest))) {
        if (!fs.existsSync(toolsDest)) {
          copy(toolsSrc, toolsDest);
        } else {
          await promptOverride(toolsSrc, toolsDest);
        }
      }
    }
  }
}

/**
 * Ensures projectName is an established answer
 */
async function answerProjectName(answeredTokens: Record<string, string>) {
  // If the project name is not provided, read the project name from the
  // package.json file. If the package has tokens for the name field, prompt for
  // the name.
  if (!answeredTokens.projectName) {
    const packagePath = path.resolve("package.json");
    const targetPackage = fs.readJSONSync(packagePath);

    // If the package.json has a name field, prompt for the name
    if (targetPackage.name) {
      // If the project name is established with no tokens, we can use that name
      if (!hasUnansweredTokens(targetPackage.name, answeredTokens)) {
        answeredTokens.projectName = targetPackage.name;
      }
    }
  }

  // If a project name is not established still, we go ahead and prompt for the
  // value
  if (!answeredTokens.projectName) {
    answeredTokens.projectName = await promptTextInput(
      "Enter the name of the project (package.name):"
    );
  }

  return answeredTokens;
}

/**
 * This copies all properties from the "targetPackage" property int he
 * package.json to the target project's package.json. This deep inspects the
 * properties for templates and replaces them with the appropriate values.
 */
async function copyTargetProperties(
  answeredTokens: Record<string, string> = {}
) {
  // Read the package.json and make sure all of the devops commands located in
  // this project's package.json are also included in the target project's
  // package.json.
  const packagePath = path.resolve(__dirname, "../../package.json");

  // Read the package.json file
  const devopsPackage = fs.readJSONSync(packagePath);
  const devopsProps: Record<string, string> = devopsPackage.targetPackage || {};

  // Ensure each script is included in the target package. If the script exists
  // already prompt for an override
  const targetPackagePath = path.resolve("./package.json");
  const targetSkeletonRcPath = path.resolve("./.skeletonrc");
  const targetPackage = fs.readJSONSync(targetPackagePath);
  let targetSkeletonRc: SkeletonRC = {
    process: [],
    tokens: {},
    answers: {},
  };

  // Load in target project skeleton schema for answers and token info
  if (fs.existsSync(targetSkeletonRcPath)) {
    targetSkeletonRc = fs.readJSONSync(targetSkeletonRcPath);

    try {
      targetSkeletonRc = SkeletonRCSchema.parse(
        targetSkeletonRc || { process: [], tokens: {} }
      );
    } catch (err) {
      if (err instanceof Error) console.error(err.stack || err.message);
      throw err;
    }
  }

  // Load in target project package.json skeleton schema for answers and token
  // info
  if (targetPackage.skeleton) {
    const targetScriptSkeleton: Partial<SkeletonRC> =
      targetPackage.skeleton || {
        process: [],
        tokens: {},
      };

    // Include skeleton config found in the target package
    if (targetScriptSkeleton) {
      if (targetScriptSkeleton.tokens) {
        Object.assign(targetSkeletonRc.tokens, targetScriptSkeleton.tokens);
      }

      if (targetScriptSkeleton.answers) {
        Object.assign(targetSkeletonRc.answers, targetScriptSkeleton.answers);
      }
    }
  }

  // Load in the skeleton schema from the package json for the target scripts
  let devopsScriptTarget: SkeletonRC | undefined;

  try {
    devopsScriptTarget = SkeletonRCSchema.parse(
      devopsPackage.skeleton || { process: [], tokens: {} }
    );
  } catch (err) {
    if (err instanceof Error) console.error(err.stack || err.message);
    throw err;
  }

  // Merge the tokens from the target package with the tokens from the devops
  // and merge the answers from the target package with the answers from the
  // devops. We will favor the target RC over the devops config.
  const tokenRc = devopsScriptTarget?.tokens || {};
  Object.assign(answeredTokens, devopsScriptTarget?.answers || {});
  Object.assign(answeredTokens, targetSkeletonRc?.answers || {});
  Object.assign(tokenRc, targetSkeletonRc?.tokens || {});

  // Ensure project name is established from some source
  await answerProjectName(answeredTokens);

  // Flatten the props to paths and values from the devops package
  const devopsPropsFlattened = flattenJSON(devopsProps);

  // Apply each path to the package with the value provided from the devops
  // package. This will perform prompts for unanswered tokens and deep inject
  // properties as discovered.
  for (const [path, value] of devopsPropsFlattened) {
    // We get the value from devops with all of the potential tokens answered.
    // This will allow for pre-answered tokens to match the target package
    // properties as the target package is expected to have answered tokens and
    // the devops source package is not.
    const answeredValue = injectWhenAllAnswered(value, answeredTokens);
    const targetValue = getJSONValue(targetPackage, path);

    // If the target already has the exact same value that we want to apply,
    // then we can move on to the next property.
    if (answeredValue === targetValue) {
      continue;
    }

    // This is a directive to see if the target package should have this value
    // deleted from it. If the value exists in the target package, prompt to
    // confirm the deletion.
    if (value === "__DEPRECATED__") {
      if (targetValue !== undefined) {
        const deleteIt = await promptConfirm(
          `Devops has detected a ${chalk.redBrightBold(
            "deprecated"
          )} script in your package.json at ${chalk.cyanBrightBold(
            path.join(".")
          )}. Would you like to remove it?\n\tCurrent Value: ${chalk.yellowBrightBold(
            targetValue
          )}`
        );

        if (deleteIt) {
          deleteJSONValue(targetPackage, path);
        }
      }
    }

    // If the target has the specified property already AND the value would be
    // changed when the new value is applied with answered tokens, then we
    // prompt for an override.
    else if (targetValue !== undefined && targetValue !== answeredValue) {
      const override = await promptConfirm(
        `Adding property package.${chalk.cyanBrightBold(
          path.join(".")
        )}, but one already seems to exist in your package.json. Would you like to override it?\n\tCurrent Value: ${chalk.yellowBrightBold(
          targetValue
        )}\n\tNew Value: ${chalk.greenBrightBold(answeredValue)}`,
        false
      );

      if (override) {
        applyJSONValue(
          targetPackage,
          path,
          await injectTokens(value, answeredTokens, tokenRc)
        );
      }
    }

    // At this point the new value doesn't exist in the target at all, so we can
    // safely inject the property.
    else {
      applyJSONValue(
        targetPackage,
        path,
        await injectTokens(value, answeredTokens, tokenRc)
      );
    }
  }

  // Write the new target package back to the file system
  fs.writeJSONSync(targetPackagePath, targetPackage, { spaces: 2 });
}

/**
 * Copies the tsconfig and the linting rules to the project root.
 */
export default async function run() {
  const proceed = await promptConfirm(
    description`
      This operation will copy configurations from the devops system to this
      project. Existing files will be prompted for a resolution and new files
      will be added without question.

      Would you like to proceed?
  `
  );

  if (!proceed) {
    console.warn("Goodbye then!");
    process.exit(0);
  }

  // Copy all files from the config folder to the target project
  await migrateFiles();
  // Copy all top level properties from the package.json to the target project
  await copyTargetProperties();
}
