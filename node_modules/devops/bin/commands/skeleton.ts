/**
 * The purpose of this command is to take in the current project and search for
 * templating items to be queried on and auto completed. This then builds out a
 * new project repo for this project to work within and performs any other
 * number of starter tasks that need to be completed.
 */

import changecase from "change-case";
import child_process from "child_process";
import fs from "fs-extra";
import inquirer, { QuestionCollection } from "inquirer";
import path from "path";
import rmrf from "rimraf";
import shell from "shelljs";
import z from "zod";
import { chalk } from "../lib/util/chalk.js";
import { template } from "../lib/util/template.js";
import { wait } from "../lib/util/wait.js";

const TEST = process.env.TEST === "true";

// Schema for skeleton command object type
export const SkeletonCommandObjectSchema = z.object({
  run: z.string(),
  fail: z.string(),
  success: z.string(),
  ignoreFailure: z.boolean().optional(),
});

/**
 * Expected schema of the .skeletonrc file
 */
export const SkeletonRCSchema = z.object({
  process: z.array(
    z.union([
      z.object({
        commands: z.array(z.union([z.string(), SkeletonCommandObjectSchema])),
      }),
      z.union([
        z.literal("skeletonFiles"),
        z.literal("gitInit"),
        z.literal("replace"),
        z.literal("removeSkeleton"),
      ]),
    ])
  ),
  tokens: z.record(
    z.object({
      description: z.string(),
    })
  ),
  answers: z.record(z.string()),
});

export type SkeletonRC = z.infer<typeof SkeletonRCSchema>;
export type SkeletonCommand =
  | string
  | z.infer<typeof SkeletonCommandObjectSchema>;

function isDefined<T>(val: any): val is T {
  return val !== void 0 && val !== null;
}

function isSpawnSyncReturns(
  val: any
): val is child_process.SpawnSyncReturns<Buffer> {
  return (
    isDefined<any>(val) &&
    isDefined<any>(val.status) &&
    isDefined<any>(val.stderr)
  );
}

/**
 * Recursively retrieve all files in a specified directory.
 */
const getAllFiles = function (
  dirPath: string,
  arrayOfFiles: string[],
  excludeDir = new Set()
) {
  if (!fs.statSync(dirPath).isDirectory()) {
    console.warn("getAllFiles: Path specified is not a directory");
  }

  const files = fs.readdirSync(dirPath);

  arrayOfFiles = arrayOfFiles || [];

  files.forEach(function (file) {
    if (fs.statSync(`${dirPath}/${file}`).isDirectory()) {
      if (excludeDir.has(file)) return;
      arrayOfFiles = getAllFiles(`${dirPath}/${file}`, arrayOfFiles);
    } else {
      arrayOfFiles.push(path.join(dirPath, "/", file));
    }
  });

  return arrayOfFiles;
};

/**
 * Retrieves the project's .skeletonrc configuration. This file is REQUIRED for
 * a skeleton project. If it does not exist or does not parse correctly, this
 * process will quit.
 */
function getSkeletonRc(projectPath: string) {
  // Read in the configuration for the skeleton and match the configuration to
  // each option discovered
  let skeletonConf: ReturnType<typeof SkeletonRCSchema.parse> = {
    process: [],
    tokens: {},
    answers: {},
  };

  try {
    const rcPath = path.resolve(projectPath, ".skeletonrc");

    if (fs.existsSync(rcPath)) {
      skeletonConf = fs.readJsonSync(rcPath);
      skeletonConf = SkeletonRCSchema.parse(skeletonConf);
    }
  } catch (e: any) {
    console.warn("Error reading .skeletonrc:");
    console.error(e ? e.stack || e.message || e : e);
    process.exit(1);
  }

  return skeletonConf;
}

/**
 * This is a finalizing process that will officially remove the skeleton file
 * on completion
 */
function removeSkeleton(projectPath: string) {
  try {
    const rcPath = path.resolve(projectPath, ".skeletonrc");

    if (fs.existsSync(rcPath)) {
      fs.removeSync(rcPath);
    }
  } catch (e: any) {
    console.warn("removeSkeleton: error finding .skeletonrc");
    console.error(e ? e.stack || e.message || e : e);
  }
}

/**
 * Processes ALL of the project files for {{tokens}} and provides what those
 * token names are.
 */
function getProjectSkeletonOptions(files: string[]) {
  const filesWithOptions: [string, string[]][] = [];

  // Read in the entire skeleton project's files and process each as text,
  // searching for template options based on the option syntax.
  files.forEach((file) => {
    const contents = fs.readFileSync(file, "utf8");
    const options: string[] = [];

    template({
      template: contents,
      doubleCurlyBrackets: true,
      options: {},

      onToken: (match, _replace) => {
        // The option key name will always be on the side of the colon which
        // delineates transformations of the term.
        const splits = match.split(":").map((x) => x.trim());
        options.push(splits[0]);
        return match;
      },
    });

    if (options.length > 0) {
      filesWithOptions.push([file, options]);
    }
  });

  // Condense all options that the skeleton project will be configuring
  const allSkeletonOptions = new Set<string>();
  filesWithOptions.forEach(([_key, options]) => {
    options.forEach((option) => allSkeletonOptions.add(option));
  });

  return { filesWithOptions, allSkeletonOptions };
}

/**
 * This does the final file structure modifications to the project. We copy the
 * skeleton files over the project files and remove the git repo and initialize
 * a new repo based on the required repoSSH property provided.
 */
async function gitInit(projectPath: string, answers: Record<string, string>) {
  // Last, we need to initialize this as a new git repository. We guarantee the
  // repoSSH property to handle this matter.
  if (!TEST) {
    await rmrf(path.resolve(projectPath, ".git")).catch((err: Error) => {
      if (err) {
        console.warn(err);
      }
    });

    // Give the filesystem a moment to flush
    await wait(100);

    if (shell.exec("git init").code !== 0) {
      console.error("Error: git init failed");
      return;
    }

    // Make sure we have a value for our repository for this step
    if (answers.repoSSH === undefined) {
      const { repoSSH } = await inquirer.prompt<{ repoSSH: string }>([
        {
          type: "input",
          name: "repoSSH",
          message: "What is the SSH URL of the git repository?",
        },
      ]);

      answers.repoSSH = repoSSH;
    }

    if (shell.exec(`git remote add origin ${answers.repoSSH}`).code !== 0) {
      console.error("Error: git remote add origin failed");
      return;
    }
  }
}

/**
 * Performs the copy of skeleton files to override their project counterparts.
 */
async function skeletonFiles(files: string[]) {
  if (!TEST) {
    // We we swap all .skeleton files with the same named file and delete the
    // skeleton file.
    files.forEach((file) => {
      if (file.endsWith(".skeleton")) {
        const replaceFile = file.replace(".skeleton", "");

        if (fs.existsSync(replaceFile)) {
          fs.removeSync(replaceFile);
        }

        fs.renameSync(file, replaceFile);

        // If the file is empty. Remove the file.
        if (fs.readFileSync(replaceFile, "utf8") == "") {
          fs.removeSync(replaceFile);
        }
      }
    });
  }
}

/**
 * Performs the replacement of {{tokens}} in the project files and saves the
 * changes in each file.
 */
async function replace(
  skeletonRc: ReturnType<typeof getSkeletonRc>,
  allSkeletonOptions: Set<string>,
  filesWithOptions: [string, string[]][]
) {
  const optionWithConfiguration = new Map();

  // Map all options that have a configuration from the skeleton file
  allSkeletonOptions.forEach((optionName) => {
    if (optionName in skeletonRc) {
      optionWithConfiguration.set(optionName, skeletonRc.tokens[optionName]);
    }
  });

  // Now generate a default configuration for any option not set in the RC file
  allSkeletonOptions.forEach((optionName) => {
    if (!optionWithConfiguration.has(optionName)) {
      optionWithConfiguration.set(optionName, {
        description: `Enter the value for ${optionName}`,
      });
    }
  });

  console.warn("Found files with options:");
  console.warn(filesWithOptions);
  console.warn("All options gathered:", allSkeletonOptions);

  // We need to ensure the property repoSSH is included in the values for the
  // sake of initializing the skeleton project.
  if (!optionWithConfiguration.has("repoSSH")) {
    optionWithConfiguration.set("repoSSH", {
      description:
        "Enter the SSH style URL for this repo, the skeleton command requires this specific field to set up the git repository.",
    });
  }

  // Now use inquirer to prompt the user for the values for each option
  const questions: (QuestionCollection & { name: string })[] = [];
  optionWithConfiguration.forEach((config, optionName) => {
    // Auto fill answers if they are provided already
    if (skeletonRc.answers[optionName]) {
      answers[optionName] = skeletonRc.answers[optionName];
    }

    // If no answer already given, we ask for an answer
    else {
      questions.push({
        type: "input",
        name: optionName,
        message: `${optionName}: ${config.description}`,
      });
    }
  });

  console.warn(
    "Asking questions for values:",
    questions.map((q) => q.name)
  );
  const answers = await inquirer.prompt<Record<string, string>>(questions);

  // Now we take the processed answers and apply them to all template options
  // across all files.
  filesWithOptions.forEach(([file]) => {
    const contents = fs.readFileSync(file, "utf8");
    const results = template({
      template: contents,
      doubleCurlyBrackets: true,
      // Inject the mapped template options with the answers
      options: answers,

      onToken: (match, _replace) => {
        match = match.trim();

        if (match in answers) {
          return answers[match];
        }

        const checks = match.split(":").map((s) => s.trim());

        if (checks[0] in answers) {
          let result: string = answers[checks[0]] || "";

          // Look for a transform to the case
          switch (checks[1]) {
            case "upper":
              result = changecase.capitalCase(result);
              break;
            case "lower":
              result = result.toLowerCase();
              break;
            case "camel":
              result = changecase.camelCase(result);
              break;
            // case "title": result = changecase.titleCase(result); break;
            case "pascal":
              result = changecase.pascalCase(result);
              break;
            case "constant":
              result = changecase.constantCase(result);
              break;
            case "sentence":
              result = changecase.sentenceCase(result);
              break;
            case "header":
              result = changecase.headerCase(result);
              break;
            case "snake":
              result = changecase.snakeCase(result);
              break;

            case "kebab":
            case "param":
              result = changecase.paramCase(result);
              break;

            default:
              result = changecase.capitalCase(result);
              break;
          }

          return result;
        }

        return match;
      },
    });

    // If we don't allow writes for testing purposes, we stop here
    if (TEST) return;
    // Write the results back to the file
    fs.writeFileSync(file, results.template);
  });

  return answers;
}

/**
 * Runs a command and sets up the ability to pass through the stdin pipe.
 */
async function runCommand(command: SkeletonCommand) {
  const run = (script: string, success?: string, fail?: string) => {
    const commandArgs = script
      .split(" ")
      .map((s) => s.trim())
      .filter(isDefined);
    if (commandArgs.length === 0) return;

    try {
      child_process.execFileSync(commandArgs[0], commandArgs.slice(1), {
        stdio: "inherit",
      });
    } catch (err) {
      if (isSpawnSyncReturns(err)) {
        if (fail) console.error(fail);
        console.error(`Error: ${command} failed with code ${err.status}`);
        return false;
      }
    }

    if (success) console.warn(success);
    else console.warn(`${command}: Completed`);

    return true;
  };

  if (typeof command === "string") {
    run(command);
  } else {
    if (
      !run(command.run, command.success, command.fail) &&
      command.ignoreFailure === false
    ) {
      process.exit(1);
    }
  }
}

/**
 * The purpose of this command is to take a project that has been "skeletonized"
 * and convert the skeleton to it's own project that has all of the fields it
 * needs populated properly filled in and set up with it's own unique repo.
 */
export default async function run(..._args: any[]) {
  const projectPath = path.resolve(".");

  // Immediately validate the skeletonrc file
  const skeletonRc = getSkeletonRc(projectPath);

  // Get all of the files in the project but exclude various dir
  const files = getAllFiles(
    projectPath,
    [],
    new Set(["node_modules", "dts", ".git"])
  );

  const { filesWithOptions, allSkeletonOptions } =
    getProjectSkeletonOptions(files);

  // Keep track of all answers provided
  const answers: Record<string, string> = {};

  // Run each process in order
  for (const skeletonProcess of skeletonRc.process) {
    if (typeof skeletonProcess === "string") {
      console.warn("Running process:", chalk.bgCyanBright(skeletonProcess));
      switch (skeletonProcess) {
        case "gitInit":
          await gitInit(projectPath, answers);
          break;

        case "skeletonFiles":
          await skeletonFiles(files);
          break;

        case "removeSkeleton":
          await removeSkeleton(projectPath);
          break;

        case "replace":
          Object.assign(
            answers,
            await replace(skeletonRc, allSkeletonOptions, filesWithOptions)
          );

          // After all of the answers have been collected, we save the answers
          // back to the .skeletonrc file for future use by any other process
          // that needs to use them.
          skeletonRc.answers = answers;

          fs.writeFileSync(
            path.join(projectPath, ".skeletonrc"),
            JSON.stringify(skeletonRc, null, 2)
          );
          await wait(500);
          break;
      }
    } else {
      const commands = skeletonProcess.commands;

      if (commands) {
        for (const command of commands) {
          await runCommand(command);
        }
      }
    }

    // Flush any file writes
    await wait(500);
  }

  console.warn(
    chalk.cyanBrightBold(
      "\nNew project created from skeleton project! Ensure git is initialized correctly and push this project to the repo as first commit!"
    )
  );
  console.warn(
    "You can now make your first commit and push to the remote repo."
  );
}
