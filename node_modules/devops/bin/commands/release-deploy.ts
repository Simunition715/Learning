import fs from "fs-extra";
import path from "path";
import releaseBuild from "./release-build.js";
import releaseNotes from "./release-view.js";
import shell from "shelljs";
import { chalk } from "../lib/util/chalk.js";
import { description } from "../lib/util/description.js";
import { gitCanAccessRemote } from "../lib/git/git-can-access-remote.js";
import { gitEnsureRemote } from "../lib/git/git-ensure-remote.js";
import { gitHasChanges } from "../lib/git/git-has-changes.js";
import { gitReturnToDev } from "../lib/git/git-return-to-dev.js";
import { gitUpdateBranch } from "../lib/git/git-update-branch.js";
import { npmRun } from "../lib/util/npm-run.js";
import { promptConfirm } from "../lib/prompt/prompt-confirm.js";
import { targetProjectRepo } from "../lib/target-project/target-project-repo.js";
import { targetProjectVersion } from "../lib/target-project/target-project-version.js";

/**
 * This is the required remote name that must be present for the release script
 * to work
 */
const ENSURE_REMOTE = "origin";

/**
 * This method checks all of the package json settings and ensures the
 * repositories listed are valid for use within this context.
 */
async function validateRepository() {
  const projectRepo = await targetProjectRepo();
  const ENSURE_REMOTE_PROJECT = projectRepo.url;

  if (
    !projectRepo ||
    !(
      projectRepo.type !== "gitlab" ||
      projectRepo.type !== "git" ||
      projectRepo.type !== "bitbucket" ||
      projectRepo.type !== "stash"
    )
  ) {
    console.warn(`
      You MUST have a repository specified in your package json to use the
      release script. It must be of 'type: git' and have a valid ssh url to
      your git repo.

      Additionally, you MUST have a remote configured for your project of
      'origin' that matches the repo url listed in your package.json.

      Thus: "git remote -v" SHOULD output a line with
      origin <url in your package json repository field> (push)
    `);
    process.exit(1);
  }

  // We check our remote to ensure we have a project with expected values
  const remoteListProcess = shell.exec("git remote -v");

  if (remoteListProcess.code !== 0) {
    console.warn("Could not list remotes for the git project.");
    process.exit(1);
  }

  const remotes = remoteListProcess.stdout.toString().split(/\r?\n/g);

  const foundRemote = remotes.find(
    (row) =>
      row.indexOf(ENSURE_REMOTE) >= 0 && row.indexOf(ENSURE_REMOTE_PROJECT) >= 0
  );

  if (!foundRemote) {
    console.warn(
      "Could not match package json repository to an origin remote in git CLI",
      ENSURE_REMOTE,
      ENSURE_REMOTE_PROJECT
    );
    process.exit(1);
  }

  // Now check to make sure the repo specified exists in git and is available to
  // the user
  if (!gitCanAccessRemote(ENSURE_REMOTE_PROJECT)) {
    console.warn(`
      You do not seem to have access to the repo listed in the package json of
      this project. Please ensure you have write access to the repo:
      ${ENSURE_REMOTE_PROJECT}
      and then try to run the release again.
    `);
    process.exit(1);
  }

  // We can only do this operation if there is nothing to commit or push
  // This only works if no changes are present
  if (await gitHasChanges()) {
    console.error(
      "You have uncommitted changes or the current state of the project can not be determined. Please commit or stash them before continuing."
    );
    process.exit(1);
  }
}

/**
 * Makes sure we are on the release branch and completely updated with the
 * contents of dev.
 */
async function checkoutRelease() {
  // Make sure we're on a release branch that matches dev
  if (shell.exec("git checkout release").code !== 0) {
    if (shell.exec("git checkout -b release").code !== 0) {
      console.warn(
        "Could not switch to the release branch. Make sure the branch exists locally."
      );
      process.exit(1);
    }
  }

  // Make sure we have the latest from the remote
  if (shell.exec(`git fetch ${ENSURE_REMOTE}`).code !== 0) {
    console.warn("Could not fetch from remote servers.");
    process.exit(1);
  }

  // Make sure we are exactly what is in dev
  if (shell.exec(`git reset --hard ${ENSURE_REMOTE}/dev`).code !== 0) {
    console.warn(`Could not reset branch to dev`);
    process.exit(1);
  }
}

/**
 * Determines the last release type based on the contents placed within the
 * release notes file.
 */
function getReleaseType() {
  try {
    const notes: string = fs.readFileSync(
      path.resolve("RELEASE_NOTES.md"),
      "utf8"
    );
    const groups = notes
      .toLowerCase()
      .split("\n")
      .map((line) => (line.match(/## (\w+)/) || [])[1])
      .filter(Boolean);
    if (groups.includes("breaking")) return "major";
    if (groups.includes("added")) return "minor";
    return "patch";
  } catch (err) {
    console.error("Could not determine release type after release was created");
    process.exit(1);
  }
}

/**
 * Update our release notes and determine what our next version is going to be
 * based on commit messages.
 */
async function updateVersion(alternate?: string) {
  // Get our current version so we can ensure our version changed.
  const currentVersion = await targetProjectVersion();

  // Ensure all fragments are going to be included in the commit
  if (shell.exec("git add -A").code !== 0) {
    console.warn(
      "Could not ensure all fragments are added for the next commit."
    );
    process.exit(1);
  }

  // Have this execute the release-notes script
  await releaseNotes({
    file: "RELEASE_NOTES.md",
    updatePackage: true,
  });

  // Get the version runner should have updated to
  const newVersion = await targetProjectVersion();

  // If our version has not changed, then there were no commits with release
  // notes
  if (currentVersion === newVersion) {
    console.warn(`
      The release script did not detect any changes for a release. If you find
      this to be in error or you want to force a new release. Make some commits
      with proper release note formatted messages to trigger a release.
    `);
    process.exit(1);
  }

  if (alternate) {
    if (getReleaseType() !== "patch") {
      console.error(`
        Cannot create a release for an alternate branch that is not a simple
        patch. Features and breaking changes can ONLY be made on the main branch of
        development.
      `);
      process.exit(1);
    }
  }

  // Get the version generated by the runner release notes commit
  const lastCommitProcess = shell.exec("git log -1 --pretty=%B");

  if (lastCommitProcess.code !== 0 || !lastCommitProcess.stdout) {
    console.warn("Could not read the last commit version information");
    process.exit(1);
  }

  const version = (
    lastCommitProcess.stdout
      .toString()
      .trim()
      .toLowerCase()
      .split("release ")[1] || ""
  ).trim();

  if (!version) {
    console.warn(
      "Could not determine release version from the last commit:\n\n",
      lastCommitProcess.stdout.toString(),
      "\n\n"
    );
    process.exit(1);
  }

  // Update the release version json in the source
  if (fs.existsSync(path.resolve("ui/release.json"))) {
    try {
      const contents = fs.readJSONSync(path.resolve("ui/release.json"));
      contents.version = version;
      fs.writeJSONSync(path.resolve("ui/release.json"), contents);
    } catch (err) {
      console.warn(
        "Could not update the release.json file with current library version."
      );
      process.exit(1);
    }

    // Add the changes to the release json file
    if (shell.exec("git add -A").code !== 0) {
      console.warn(
        "Could not ensure the release json was updated for the new version."
      );
      process.exit(1);
    }

    // Amend the release commit
    if (shell.exec("git commit --amend --no-edit").code !== 0) {
      console.warn(
        "Could not amend the release commit to include the release json file."
      );
      process.exit(1);
    }
  }

  return version;
}

/**
 * This generates a tag for the given release
 */
async function updateTag(version: string) {
  // Tag the commit with the version number
  if (shell.exec(`git tag -a ${version} -m "Release ${version}"`).code !== 0) {
    console.warn("Could not make tag for git commit");
    process.exit(1);
  }
}

/**
 * This performs all actions to pushing the generated results to the remote
 * repository
 */
async function pushToRemote(
  remote: string,
  version: string,
  fromBranch: string,
  toBranch: string,
  force: boolean
) {
  // Push the commit to remote release branch
  if (
    shell.exec(
      `git push ${remote}${force ? " -f " : ""}${fromBranch}:${toBranch}`
    ).code !== 0
  ) {
    console.warn(`Could not push release commit to ${remote}`);
    process.exit(1);
  }

  // Push the tag to remote
  if (shell.exec(`git push ${remote} ${version}`).code !== 0) {
    console.warn("Could not push tag to the remote repository");
    process.exit(1);
  }
}

/**
 * This will ensure each remote is accessible by the user and will push the
 * release branch to each of the specified remotes at the potential target
 * branch:
 *
 * remote:fromBranch:toBranch:force
 *
 * If the branch is not specified, the branch specified for this project will
 * be used.
 *
 * The "force" option is literal. Use the word "force" to trigger a force push.
 */
async function releaseAdditionalRemotes(addRemotes: string[], version: string) {
  if (addRemotes && addRemotes.length > 0) {
    const shouldReleaseRemotes = await promptConfirm(
      description`
        The build and release was successful, would you like to release to the
        specified additional remotes?

        ${chalk.cyanBrightBold(addRemotes.join("\n"))}
      `
    );

    if (!shouldReleaseRemotes) return;
  }

  // Do a fetch again to ensure we have the latest from the remote
  if (shell.exec(`git fetch ${ENSURE_REMOTE}`).code !== 0) {
    console.warn("Could not fetch from remote servers.");
    process.exit(1);
  }

  for (const remoteInfo of addRemotes) {
    // Push the release to the specified remotes
    const [remote, fromBranch, toBranch, force] = remoteInfo.split(":");
    // Make sure the dev has access to the specified remote
    await gitEnsureRemote(remote);
    // Reset the fromBranch to it's latest from origin
    await gitUpdateBranch(ENSURE_REMOTE, fromBranch || "master");
    // Deploy to the configured branch or to master
    await pushToRemote(
      remote,
      version,
      fromBranch || "master",
      toBranch || "master",
      force === "force"
    );
  }
}

/**
 * This performs all of the build actions to generate all fragments the project
 * will generate for distributions and then will push those fragments into the
 * repo.
 */
async function buildAndPush(addRemotes: string[]) {
  // Process and set environment variables
  process.env.NODE_ENV = "production";

  // Make sure we can make calls to the repo
  await validateRepository();
  // Move our git context to the release branch
  await checkoutRelease();
  // Build the project fragments
  await releaseBuild();
  // Get the new version this release is going to become.
  const version = await updateVersion();
  // Tag the release commit with the latest version
  await updateTag(version);
  // Push everything we have updated with git to the remote repo
  await pushToRemote(ENSURE_REMOTE, version, "release", "release", true);

  // Ask to run the pr release script
  const shouldPr = await promptConfirm("Would you like to run pr release?");

  if (shouldPr) {
    // Attempt to run pr release. We don't care if it works or not as this is an
    // optional branch taken by the user anywho.
    await npmRun("pr", ["release"]);
  }

  // Ask to deploy additional specified remotes
  await releaseAdditionalRemotes(addRemotes, version);
  // Now we ask to return to original branch
  await gitReturnToDev(true);
}

/**
 * Entry method for the release process
 */
export default async function run(addRemotes: string[]) {
  console.warn("Executing release script");
  buildAndPush(addRemotes);
}
