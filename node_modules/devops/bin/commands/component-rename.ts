import fs from "fs";
import inquirer from "inquirer";
import path from "path";
import url from "url";
import { chalk } from "../lib/util/chalk.js";
import { fuzzySource } from "../lib/util/fuzzy-source.js";
import { paramCase, pascalCase } from "change-case";
import { promptConfirm } from "../lib/prompt/prompt-confirm.js";

const __dirname = url.fileURLToPath(new URL(".", import.meta.url));

// An easy toggle file write on/off for testing purposes
const allowUpdateFiles = true;

type Paths = {
  componentsPath: string;
  storiesComponents: string;
  storiesData: string;
};

type Selections = {
  directory: string;
  oldComponent: string;
  oldKebab: string;
  newComponent: string;
  newKebab: string;
  barrel: string;
};

type NameChange = {
  from: string;
  to: string;
}[];

type ContentChange = {
  path: string;
  from: string;
  to: string;
}[];

/**
 * Find all components in a directory
 */
function getAllComponents(dirPath: string, out?: string[]) {
  const files = fs.readdirSync(dirPath);
  let arrayOfFiles = out || [];

  files.forEach(function (file) {
    if (fs.statSync(`${dirPath}/${file}`).isDirectory()) {
      arrayOfFiles = getAllComponents(`${dirPath}/${file}`, arrayOfFiles);
    } else {
      // Only add the file if it contains a React.forwardRef
      if (
        fs
          .readFileSync(`${dirPath}/${file}`, "utf8")
          .includes("React.forwardRef")
      ) {
        arrayOfFiles.push(path.join(__dirname, dirPath, "/", file));
      }
    }
  });

  return arrayOfFiles;
}

/**
 * Ensure this project matches the requirements for generating a new component.
 */
async function checkStructure(): Promise<Paths> {
  const componentsPath = path.resolve("ui/components");
  const storiesPath = path.resolve("ui/stories");
  const storiesComponents = path.resolve(storiesPath, "components");
  const storiesData = path.resolve(storiesPath, "data");
  let fail = "";

  if (
    !fs.existsSync(componentsPath) ||
    !fs.statSync(componentsPath).isDirectory()
  ) {
    fail += `${componentsPath} not found or is not a directory\n`;
  }

  if (!fs.existsSync(storiesPath) || !fs.statSync(storiesPath).isDirectory()) {
    fail += `${storiesPath} not found or is not a directory\n`;
  }

  if (
    !fs.existsSync(storiesComponents) ||
    !fs.statSync(storiesComponents).isDirectory()
  ) {
    fail += `${storiesComponents} not found or is not a directory\n`;
  }

  if (!fs.existsSync(storiesData) || !fs.statSync(storiesData).isDirectory()) {
    fail += `${storiesData} not found or is not a directory\n`;
  }

  if (fail) {
    console.warn(fail);
    process.exit(1);
  }

  const out: Paths = {
    componentsPath,
    storiesComponents,
    storiesData,
  };

  return out;
}

/**
 * Get old and new names for the component
 *
 * @param paths
 * @param names
 * @returns
 */
async function requestNames(paths: Paths, name: string) {
  // Get a list of every component
  const allComponents = getAllComponents(paths.componentsPath);
  const checkFiles = new Map();
  allComponents.forEach((f) => checkFiles.set(path.basename(f), f));

  // Names
  let oldName = name;

  // Select the component to rename if not provided
  if (!name) {
    const allComponents = getAllComponents(paths.componentsPath);
    const checkFiles = new Set<string>();
    allComponents.forEach((f) =>
      checkFiles.add(path.basename(f).split(".").slice(0, -1).join("."))
    );

    const { selectedName } = await inquirer.prompt<{
      selectedName: string;
    }>([
      {
        type: "autocomplete",
        name: "selectedName",
        message: "Select a component to rename:",
        source: fuzzySource(Array.from(checkFiles.values())),
      },
    ]);

    oldName = selectedName;
  }

  // Get old component names
  const oldComponent = pascalCase(
    oldName
      .split(" ")
      .map((s) => pascalCase(s))
      .join("")
  );
  const oldKebab = paramCase(oldComponent);

  // Exit if the specified component does not exist
  const checkOldName = `${oldKebab}.tsx`;
  if (!checkFiles.has(checkOldName)) {
    const message = replaceColor(
      `A component with the name ${checkOldName} does not exist.`,
      checkOldName,
      chalk.redBright
    );
    console.warn(message);
    process.exit(0);
  }

  // Enter a new name for the component if not provided
  const { selectedNewName } = await inquirer.prompt<{
    selectedNewName: string;
  }>([
    {
      type: "input",
      name: "selectedNewName",
      message: "Enter a new name for the component:",
      default: "",
      filter: (input: string) => {
        if (!input || input.trim() === "") {
          console.warn("You must provide a new name for the component.");
          process.exit(1);
        }
        return input;
      },
    },
  ]);

  const newName = selectedNewName;

  // Search for this component name within the components folder to find
  // component with matching name
  const componentPath =
    checkFiles.get(`${oldName}.tsx`) ||
    checkFiles.get(`${paramCase(oldName)}.tsx`);
  let selectedDirectory = "";

  // See if we have a match with a component name
  if (componentPath) {
    selectedDirectory = path.basename(
      path.dirname(path.dirname(componentPath))
    );
  } else {
    const altName = paramCase(oldName);
    if (altName === oldName) {
      console.warn(`Unable to find a component with name ${oldName}.tsx`);
    } else {
      console.warn(
        `Unable to find a component with name ${oldName}.tsx or ${paramCase(
          oldName
        )}.tsx`
      );
    }
    process.exit(0);
  }

  // Get new component names
  const newComponent = pascalCase(
    newName
      .split(" ")
      .map((s) => pascalCase(s))
      .join("")
  );
  const newKebab = paramCase(newComponent);

  // Get filepath for the component
  const filepath = path.resolve(
    paths.componentsPath,
    selectedDirectory,
    oldKebab,
    `${oldKebab}.tsx`
  );

  // Get the barrel file that is the immediate parent
  const barrelFile = path.resolve(filepath, "../../index.ts");

  // Exit if the new name already exists
  const checkName = `${newKebab}.tsx`;
  if (checkFiles.has(checkName)) {
    const message = replaceColor(
      `A component with the name ${checkName} already exists.`,
      checkName,
      chalk.redBright
    );
    console.warn(message);
    process.exit(0);
  }

  return {
    directory: selectedDirectory,
    oldComponent: oldComponent,
    oldKebab: oldKebab,
    newComponent: newComponent,
    newKebab: newKebab,
    barrel: barrelFile,
  };
}

// FUnction called replaceColor that colors only matching text. There are three
// parameters, text string for the message, text to match, and color to use.
function replaceColor(
  text: string,
  match: string,
  color: (typeof chalk)[keyof typeof chalk]
) {
  return text.replace(new RegExp(match, "g"), color(match));
}

function showChanges(changes: NameChange | ContentChange) {
  // process.stdout for each fileNameChanges
  changes.forEach((f) => {
    const fromName = replaceColor(
      f.from,
      path.basename(f.from),
      chalk.cyanBright
    );
    const toName = chalk.yellow(path.basename(f.to));
    process.stdout.write(`- ${fromName} -> ${toName}\n`);
  });
  process.stdout.write(`\n`);
}

/**
 * Opens the file fragments
 */
async function replaceNames(paths: Paths, selections: Selections) {
  const oldComponent = selections.oldComponent;
  const newComponent = selections.newComponent;
  const kebabName = selections.oldKebab;
  const newKebabName = selections.newKebab;

  // Open file fragments
  try {
    // Create new array to hold each of the files below
    const files = [];

    // Get the path to all of the related files
    files.push(
      path.resolve(
        paths.componentsPath,
        selections.directory,
        kebabName,
        `${kebabName}.tsx`
      )
    );
    files.push(
      path.resolve(
        paths.componentsPath,
        selections.directory,
        kebabName,
        `${kebabName}.scss`
      )
    );
    files.push(
      path.resolve(
        paths.storiesComponents,
        selections.directory,
        `${kebabName}.stories.tsx`
      )
    );
    files.push(
      path.resolve(
        paths.storiesData,
        selections.directory,
        `${kebabName}-props.tsx`
      )
    );

    // The folder name
    const folder = path.resolve(
      paths.componentsPath,
      selections.directory,
      kebabName
    );

    // The folder name
    const newFolder = path.resolve(
      paths.componentsPath,
      selections.directory,
      newKebabName
    );

    // File changes to make, must be made in this order
    const fileContentChanges: ContentChange = [];
    const fileNameChanges: NameChange = [];
    const folderNameChanges: NameChange = [];

    // Add the folder change to the queue
    folderNameChanges.push({
      from: folder,
      to: newFolder,
    });

    // Loop through every file
    for (const file of files) {
      const contents = fs.readFileSync(file, "utf8");
      const filePath = path.dirname(file);
      const filename = path.basename(file);

      // Replace contents
      const newContents = contents
        .replace(new RegExp(oldComponent, "g"), newComponent)
        .replace(new RegExp(kebabName, "g"), newKebabName);

      // Get new filename
      const newName = filename.replace(
        new RegExp(kebabName, "g"),
        newKebabName
      );

      // Get old and new file paths
      const currentFilePath = path.resolve(filePath, filename);
      const newFilePath = path.resolve(filePath, newName);

      // Add file contents to the queue
      fileContentChanges.push({
        path: currentFilePath,
        from: contents,
        to: newContents,
      });

      // Add file name changes to the queue
      fileNameChanges.push({
        from: currentFilePath,
        to: newFilePath,
      });
    }

    // Write message to console
    process.stdout.write(chalk.cyanBrightBold("FILE CHANGES:\n"));
    showChanges(fileNameChanges);

    // Show folder changes
    process.stdout.write(chalk.cyanBrightBold("FOLDER CHANGES:\n"));
    showChanges(folderNameChanges);

    // Confirm proceed
    const confirmProceed = await promptConfirm("Do you want to proceed?");

    if (confirmProceed) {
      // Make content changes
      fileContentChanges.forEach((f) => {
        if (allowUpdateFiles) {
          fs.writeFileSync(f.path, f.to, "utf8");
        }
      });

      // Change file names
      fileNameChanges.forEach((f) => {
        if (allowUpdateFiles) {
          fs.renameSync(f.from, f.to);
        }
      });

      // Change folder names
      folderNameChanges.forEach((f) => {
        if (allowUpdateFiles) {
          fs.renameSync(f.from, f.to);
        }
      });

      // Update the barrel file
      updateBarrel(selections);

      // Display complete message
      const completeMessage = chalk.greenBrightBold(
        "\nCOMPONENT FILES SUCCESSFULLY UPDATED\n"
      );
      process.stdout.write(completeMessage);
    } else {
      process.stdout.write("Thank you, please come again!\n");
      process.exit(0);
    }
  } catch (err) {
    console.warn("Could not open all file fragments:\n", err);
    process.exit(1);
  }
}

/**
 * This finds the nearest barrel file (parent barrel) to the renamed
 * component and updates the component exports.
 */
async function updateBarrel(selections: Selections) {
  // Get the barrel file that is the immediate parent
  const properBarrel = selections.barrel;

  // We should require the barrel to be the immediate parent.
  if (!fs.existsSync(properBarrel)) {
    console.warn(
      `Not found: ${properBarrel}`,
      "A parent barrel file for the generated component does not exist and thus this component will not be exported with the library."
    );
    return;
  }

  // Replace all instances of selections.oldKebab with selections.newKebab
  const contents = fs.readFileSync(properBarrel, "utf8");
  const newContents = contents.replace(
    new RegExp(selections.oldKebab, "g"),
    selections.newKebab
  );

  if (allowUpdateFiles) {
    fs.writeFileSync(properBarrel, newContents, "utf8");
  }
}

/**
 * This command will establish that this is a storybook based project with a
 * certain layout. Then, this will create and update all of the fragments needed
 * to add a new component to the library project, which includes:
 *
 * - component.tsx
 * - component.scss
 * - component.stories.tsx (for testing)
 * - component-props.tsx (for testing)
 * - update nearest barrel file to export the new component
 * - open all of the new fragments in the current editor
 */
export default async function run(name: string, ..._args: any[]) {
  // Validate the project structure and provide the paths that have been
  // determined valid.
  const paths = await checkStructure();

  // Requests the directory and the component name from the user
  const selections = await requestNames(paths, name);

  // Replace all instances of the old name with the new name
  await replaceNames(paths, selections);
}
