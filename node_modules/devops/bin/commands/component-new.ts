import changecase from "change-case";
import fs from "fs-extra";
import path from "path";
import url from "url";
import { caseTransformTokens } from "../lib/template/case-transform-tokens.js";
import {
  checkComponentStructure,
  Paths,
} from "../lib/component/check-component-structure.js";
import { description } from "../lib/util/description.js";
import { generateCategory } from "../lib/component/generate-category.js";
import { getComponentPaths } from "../lib/component/get-component-paths.js";
import { openFile } from "../lib/file-management/open-file.js";
import { paramCase, pascalCase } from "change-case";
import { promptSelect } from "../lib/prompt/prompt-select.js";
import { promptTextInput } from "../lib/prompt/prompt-text-input.js";
import { targetProjectPackage } from "../lib/target-project/target-project-package.js";
import { wait } from "../lib/util/wait.js";
import { writeFilePrompt } from "../lib/file-management/write-file-prompt.js";

const __dirname = url.fileURLToPath(new URL(".", import.meta.url));
type Selections = Awaited<ReturnType<typeof requestName>>;

/**
 * This prompts the user for the component name and directory of choice.
 */
async function requestName(paths: Paths, name: string) {
  const files = fs.readdirSync(paths.componentsPath);
  const directorySuggestions: string[] = [];

  files.forEach((file) => {
    const filePath = path.resolve(paths.componentsPath, file);
    if (fs.statSync(filePath).isDirectory()) {
      directorySuggestions.push(file);
    }
  });

  directorySuggestions.push("New...");

  let selectedDirectory = await promptSelect(
    "Start typing to select the directory to add your new component:",
    directorySuggestions
  );

  if (selectedDirectory === "New...") {
    selectedDirectory = await promptTextInput(
      "Type a name for the new directory:"
    );
  }

  if (!name) {
    const selectedName = await promptTextInput(
      "Type a name for the component:"
    );

    name = selectedName;
  }

  name = pascalCase(
    name
      .split(" ")
      .map((s) => pascalCase(s))
      .join("")
  );

  if (!selectedDirectory) {
    throw new Error(
      "No directory selected for writing new component. Aborting..."
    );
  }

  // Let's also get the name of the project from the package json
  const packageJson = await targetProjectPackage();
  const project = packageJson.name || "";

  return {
    directory: selectedDirectory,
    name,
    project,
  };
}

/**
 * Ensures a directory exists. DOes not attempt anything if already exists to
 * prevent errors.
 */
async function mkDir(path: string) {
  if (fs.existsSync(path)) return;
  fs.ensureDirSync(path);
}

/**
 * Generates the file fragments
 */
async function generateFragments(paths: Paths, selections: Selections) {
  const templatePath = path.resolve(__dirname, "../lib/template");
  const newComponentTemplatePath = path.resolve(templatePath, "new-component");

  // If the selected directory doesn't exist yet, we need to make it and
  // populate it with the template empty component
  if (
    !fs.existsSync(path.resolve(paths.componentsPath, selections.directory))
  ) {
    await generateCategory(paths, selections);
  }

  if (!fs.existsSync(newComponentTemplatePath)) {
    throw new Error(`${newComponentTemplatePath} was not found`);
  }

  if (
    !fs.existsSync(
      path.resolve(newComponentTemplatePath, "component.template")
    ) ||
    !fs.existsSync(path.resolve(newComponentTemplatePath, "props.template")) ||
    !fs.existsSync(path.resolve(newComponentTemplatePath, "scss.template")) ||
    !fs.existsSync(path.resolve(newComponentTemplatePath, "story.template"))
  ) {
    throw new Error(
      `All templates within ${newComponentTemplatePath} were not found`
    );
  }

  // This maps all of the terms in the templates to the values they should be
  // based on the innput from the user.
  const options: Record<string, string> = {
    name: selections.name,
    directory: changecase.paramCase(selections.directory),
    project: selections.project,
  };

  // Generate all of the contents of our files by replacing the relevant terms
  const componentTemplate = caseTransformTokens(
    options,
    path.resolve(newComponentTemplatePath, "component.template")
  );

  const propsTemplate = caseTransformTokens(
    options,
    path.resolve(newComponentTemplatePath, "props.template")
  );

  const scssTemplate = caseTransformTokens(
    options,
    path.resolve(newComponentTemplatePath, "scss.template")
  );

  const storyTemplate = caseTransformTokens(
    options,
    path.resolve(newComponentTemplatePath, "story.template")
  );

  // Ensure all of the options within each template has been resolved
  if (
    componentTemplate.unresolvedTemplateOptions.size > 0 ||
    propsTemplate.unresolvedTemplateOptions.size > 0 ||
    scssTemplate.unresolvedTemplateOptions.size > 0 ||
    storyTemplate.unresolvedTemplateOptions.size > 0
  ) {
    console.warn("Failed to resolve all of a templates terms", {
      componentTemplate: componentTemplate.unresolvedTemplateOptions,
      propsTemplate: propsTemplate.unresolvedTemplateOptions,
      scssTemplate: scssTemplate.unresolvedTemplateOptions,
      storyTemplate: storyTemplate.unresolvedTemplateOptions,
    });
    process.exit(1);
  }

  // Create the directories and file fragments
  try {
    const kebabName = paramCase(selections.name);

    // Make a new folder to contain our component within
    await mkDir(
      path.resolve(paths.componentsPath, selections.directory, kebabName)
    );
    // Ensure we have a matching directory in our stories components for our
    // selected directory.
    await mkDir(path.resolve(paths.storiesComponents, selections.directory));
    // Ensure we have a matching directory in our stories data for our
    // selected directory.
    await mkDir(path.resolve(paths.storiesData, selections.directory));
    // Form all of the paths to each component file
    const allPaths = await getComponentPaths(paths, selections);

    // Write the component template files
    const componentPath = await writeFilePrompt(
      allPaths.component,
      `${componentTemplate.template.trim()}\n`
    );
    const scssPath = await writeFilePrompt(
      allPaths.scss,
      `${scssTemplate.template.trim()}\n`
    );
    // Write our story template
    const storyPath = await writeFilePrompt(
      allPaths.stories[0],
      `${storyTemplate.template.trim()}\n`
    );
    // Write our story data template
    const propsPath = await writeFilePrompt(
      allPaths.props[0],
      `${propsTemplate.template.trim()}\n`
    );

    // Open the written files for review
    await wait(100);
    await openFile([
      componentPath,
      scssPath,
      storyPath,
      propsPath,
      componentPath,
    ]);
  } catch (err) {
    console.warn("Could not create all file fragments:\n", err);
    process.exit(1);
  }
}

/**
 * This finds the nearest barrel file (parent barrel) to the newly created
 * component and adds the new component to the exports.
 */
async function updateBarrel(paths: Paths, selections: Selections) {
  const kebabName = paramCase(selections.name);
  const filePath = path.resolve(
    paths.componentsPath,
    selections.directory,
    kebabName,
    `${kebabName}.tsx`
  );

  // Get the barrel file that is the immediate parent
  const properBarrel = path.resolve(filePath, "../../index.ts");

  // We should require the barrel to be the immediate parent.
  if (!fs.existsSync(properBarrel)) {
    console.warn(description`
      Not found: ${properBarrel}
      A parent barrel file for the generated component does not exist and thus
      this component will not be exported with the library.
    `);
    return;
  }

  let barrel = fs.readFileSync(properBarrel, { encoding: "utf-8" });
  // Clear exact same export
  barrel = barrel
    .split(`export * from "./${kebabName}/${kebabName}";`)
    .map((s) => s.trim())
    .join("\n");
  // Inject the export at the bottom of the barrel
  barrel = `${barrel.trim()}\nexport * from "./${kebabName}/${kebabName}";\n`;
  // Write the new barrel
  fs.writeFileSync(properBarrel, `${barrel.trim()}\n`, { encoding: "utf-8" });
  // Open the barrel file for review
  await openFile(properBarrel);
}

/**
 * This command will establish that this is a storybook based project with a
 * certain layout. Then, this will create and update all of the fragments needed
 * to add a new component to the library project, which includes:
 *
 * - component.tsx
 * - component.scss
 * - component.stories.tsx (for testing)
 * - component-props.tsx (for testing)
 * - update nearest barrel file to export the new component
 * - open all of the new fragments in the current editor
 */
export default async function run(name: string, ..._args: any[]) {
  // Validate the project structure and provide the paths that have been
  // determined valid.
  const paths = await checkComponentStructure();
  // Requests the directory and the component name from the user
  const selections = await requestName(paths, name);
  // Perform the file creation by utilizing the templates
  await generateFragments(paths, selections);
  // Make sure the barrel file exports our component so it is included in the
  // output library.
  await updateBarrel(paths, selections);
}
