import fs from "fs-extra";
import inquirer from "inquirer";
import path from "path";
import { chalk } from "../lib/util/chalk.js";
import { fuzzySource } from "../lib/util/fuzzy-source.js";
import { paramCase, pascalCase } from "change-case";
import { promptConfirm } from "../lib/prompt/prompt-confirm.js";

type Paths = {
  valid: boolean;
  projectPath: string;
  componentsPath: string;
  storiesComponents: string;
  storiesData: string;
};

type ComponentPaths = {
  exists: boolean;
  category: string;
  kebab: string;
  pascal: string;
  component: string;
  scss: string;
  stories: string;
  data: string;
  barrel: string;
};

type ComponentInfo = {
  path: string;
  category: string;
  name: string;
};

// FUnction called replaceColor that colors only matching text. There are three
// parameters, text string for the message, text to match, and color to use.
function replaceColor(
  text: string,
  match: string[] | string,
  color: (typeof chalk)[keyof typeof chalk]
) {
  if (Array.isArray(match)) {
    return match.reduce((acc, m) => {
      return acc.replace(new RegExp(m, "g"), color(m));
    }, text);
  }
  return text.replace(new RegExp(match, "g"), color(match));
}

/**
 * Ensure this project matches the requirements for generating a new component.
 */
async function checkStructure(root = ".", exitOnFail = true): Promise<Paths> {
  const projectPath = path.resolve(root);
  const componentsPath = path.resolve(root, "ui/components");
  const storiesPath = path.resolve(root, "ui/stories");
  const storiesComponents = path.resolve(storiesPath, "components");
  const storiesData = path.resolve(storiesPath, "data");
  let fail = "";

  if (
    !fs.existsSync(componentsPath) ||
    !fs.statSync(componentsPath).isDirectory()
  ) {
    fail += `${componentsPath} not found or is not a directory\n`;
  }

  // Default action is to exit on failure
  if (fail && exitOnFail) {
    exitWarning(fail);
  }

  const out: Paths = {
    valid: !fail,
    projectPath,
    componentsPath,
    storiesComponents,
    storiesData,
  };

  return out;
}

/**
 * Find all components in a directory
 */
function getAllComponents(dirPath: string, out?: string[]) {
  const files = fs.readdirSync(dirPath);
  let arrayOfFiles = out || [];

  files.forEach(function (file) {
    if (fs.statSync(`${dirPath}/${file}`).isDirectory()) {
      arrayOfFiles = getAllComponents(`${dirPath}/${file}`, arrayOfFiles);
    } else {
      // Only add the file if it contains a React.forwardRef
      if (
        fs
          .readFileSync(`${dirPath}/${file}`, "utf8")
          .includes("React.forwardRef")
      ) {
        arrayOfFiles.push(path.join(dirPath, "/", file));
      }
    }
  });

  return arrayOfFiles;
}

function getComponentCategories(components: string[]) {
  const categories = new Set<string>();
  components.forEach((component) => {
    const category = path.basename(path.dirname(path.dirname(component)));
    categories.add(category);
  });
  return Array.from(categories);
}

function getComponentInfo(
  component: string,
  allComponents: string[]
): ComponentInfo {
  const defaultInfo = {
    path: "",
    category: "",
    name: "",
  };
  if (!component) {
    return defaultInfo;
  }
  const found = allComponents.find((file) => {
    return path.basename(file).includes(`${component}.tsx`);
  });
  if (!found) {
    return defaultInfo;
  }
  return {
    path: found,
    category: path.basename(path.dirname(path.dirname(found))),
    name: path.basename(found, path.extname(found)),
  };
}

/**
 * Get list of folders for a specified path that checkStructure has determined
 * are valid projects.
 */
async function getProjects(root: string, paths: Paths): Promise<string[]> {
  const projects: string[] = [];
  const files = fs.readdirSync(root);

  for (const file of files) {
    const filePath = path.resolve(root, file);
    const checkProject = await checkStructure(filePath, false);
    if (checkProject.valid && filePath !== paths.projectPath) {
      projects.push(file);
    }
  }

  // If no valid projects are found, inform the user and exit
  if (!projects.length) {
    const message = replaceColor(
      `No valid devops projects were found in ${root}`,
      root,
      chalk.redBrightBold
    );
    console.warn(message);
    process.exit(1);
  }

  return projects;
}

function exitWarning(message: string, highlightText = "") {
  console.warn(replaceColor(message, highlightText, chalk.redBrightBold));
  process.exit(1);
}

/**
 * Get the source project and verify it is a valid project. If a path is not
 * provided, the user will be prompted to provide one.
 *
 * @param source Optional path to the source project
 * @returns
 */
async function getSource(source: string, paths: Paths): Promise<Paths> {
  // Set path
  let sourcePath = source;
  let checkProject: Paths;

  // Check to see if source is a valid path
  const checkSource = path.resolve(sourcePath);
  if (source && !fs.existsSync(checkSource)) {
    exitWarning(`The source path does not exist: ${sourcePath}`, sourcePath);
  }

  // Prompt uoser to provide a source path if one was not provided
  if (!source) {
    const { selectedPath } = await inquirer.prompt<{
      selectedPath: string;
    }>([
      {
        type: "input",
        name: "selectedPath",
        message: "Absolute or relative path to source project:",
        default: "../",
      },
    ]);
    sourcePath = selectedPath;
  }

  // Check structure of the source project
  checkProject = await checkStructure(sourcePath, false);

  // If the source path is not a project, allow the user to select a folder from
  // the path provided to become the source path.
  if (!checkProject.valid) {
    const { selectedPath } = await inquirer.prompt<{
      selectedPath: string;
    }>([
      {
        type: "autocomplete",
        name: "selectedPath",
        message: "Select a source project:",
        source: fuzzySource(await getProjects(sourcePath, paths)),
      },
    ]);
    sourcePath = path.resolve(sourcePath, selectedPath);
  }

  // Check structure of the source project
  checkProject = await checkStructure(sourcePath, false);

  // Inform the user if the selected project is not valid
  if (!checkProject.valid) {
    exitWarning(`The selected project is not valid: ${sourcePath}`, sourcePath);
  }

  // If the path is a real project, then proceed
  return checkProject;
}

async function getComponentFiles(
  component: string,
  category: string,
  paths: Paths
): Promise<ComponentPaths> {
  const kebabName = paramCase(component);
  const files: string[] = [];
  const missing: string[] = [];
  // Get main component file
  files.push(
    path.resolve(paths.componentsPath, category, kebabName, `${kebabName}.tsx`)
  );
  // Get stories file
  files.push(
    path.resolve(paths.storiesComponents, category, `${kebabName}.stories.tsx`)
  );
  // Get data file
  files.push(
    path.resolve(paths.storiesData, category, `${kebabName}-props.tsx`)
  );
  // Get the barrel file
  files.push(path.resolve(paths.componentsPath, category, "./index.ts"));
  // Loop through each file to see if it exists
  files.forEach((file) => {
    if (!fs.existsSync(file)) {
      missing.push(file);
    }
  });
  // IF there are no missing files, proceed
  return {
    exists: missing.length === 0,
    category: category,
    kebab: kebabName,
    pascal: pascalCase(component),
    component: files[0],
    scss: files[0].replace(".tsx", ".scss"),
    stories: files[1],
    data: files[2],
    barrel: files[3],
  };
}

function componentDisplay(allComponents: string[]) {
  const checkFiles = new Set<string>();
  allComponents.forEach((f) => {
    const parts = f.split("/").reverse();
    const basename = path.basename(f).split(".").slice(0, -1).join(".");
    checkFiles.add(`${parts[2]} / ${basename}}`);
  });
  return checkFiles;
}

/**
 * Get the component from the source project and verify it is a valid component
 * before proceeding.
 *
 * @param component
 * @param paths
 */
async function getSrcComponent(
  component: string,
  paths: Paths
): Promise<ComponentPaths> {
  // Get all components from paths
  const allComponents = getAllComponents(paths.componentsPath);

  const filteredComponents = componentDisplay(allComponents);
  const { selectedComponent } = await inquirer.prompt<{
    selectedComponent: string;
  }>([
    {
      type: "autocomplete",
      name: "selectedComponent",
      message: "Select a component:",
      source: fuzzySource(filteredComponents),
    },
  ]);
  const parts = selectedComponent.split("/");
  const category = parts[0].trim();
  component = parts[1].trim();

  const componentFiles = await getComponentFiles(component, category, paths);

  return componentFiles;
}

/**
 * Get the destination category from the current project and verify that the
 * selected component is not a duplicate before copying.
 *
 * @param component
 * @param paths
 */
async function getDestComponent(
  src: ComponentPaths,
  paths: Paths
): Promise<ComponentPaths> {
  const component = src.kebab;
  const category = src.category;
  let newCategory = category;

  // Get all components from paths
  const allComponents = getAllComponents(paths.componentsPath);
  const categories = getComponentCategories(allComponents);
  categories.push("New...");

  // Does the component exist?
  const found = getComponentInfo(component, allComponents);

  // Make sure the component does not already exist
  if (found.path) {
    exitWarning(
      `A component with that name already exists: ${found.path}`,
      found.path
    );
  }

  // Prompt the user to select from the categories, default to category
  const { selectedCategory } = await inquirer.prompt<{
    selectedCategory: string;
  }>([
    {
      type: "autocomplete",
      name: "selectedCategory",
      message: "Select a destination category:",
      source: fuzzySource(categories),
      default: category,
    },
  ]);

  newCategory = selectedCategory;

  // If selected category is "New...", prompt the user to enter a new category
  if (newCategory === "New...") {
    const { newCategoryName } = await inquirer.prompt<{
      newCategoryName: string;
    }>([
      {
        type: "input",
        name: "newCategoryName",
        message: "Enter a new category:",
      },
    ]);
    newCategory = newCategoryName;
  }

  const componentFiles = await getComponentFiles(component, newCategory, paths);

  return componentFiles;
}

/**
 * Ensures a directory exists. DOes not attempt anything if already exists to
 * prevent errors.
 */
async function mkDir(path: string) {
  try {
    if (!(await fs.pathExists(path))) {
      const message = replaceColor(
        `Creating directory: ${path}\n`,
        path,
        chalk.cyanBrightBold
      );
      process.stdout.write(message);
      await fs.mkdirp(path);
    }
  } catch (error) {
    throw new Error(`Error creating directory: ${path}`);
  }
}

/**
 * Copy files from one place to another place
 *
 * @param src
 * @param dst
 */
async function copyFile(src: string, dst: string) {
  try {
    const message = replaceColor(
      `Copying ${src} to ${dst}\n`,
      [src, dst],
      chalk.cyanBrightBold
    );
    process.stdout.write(message);
    await fs.copyFile(src, dst);
  } catch (error) {
    throw new Error(`Error copying file: ${src}`);
  }
}

/**
 * This finds the nearest barrel file (parent barrel) to the newly created
 * component and adds the new component to the exports.
 */
async function updateBarrel(paths: ComponentPaths) {
  const properBarrel = path.resolve(paths.barrel);

  // Create the barrel file if it doesn't exist
  if (!fs.existsSync(properBarrel)) {
    fs.writeFileSync(properBarrel, "", { encoding: "utf-8" });
  }

  let barrel = fs.readFileSync(properBarrel, { encoding: "utf-8" });
  // Clear exact same export
  barrel = barrel
    .split(`export * from "./${paths.kebab}/${paths.kebab}";`)
    .map((s) => s.trim())
    .join("\n");
  // Inject the export at the bottom of the barrel
  barrel = `${barrel.trim()}\nexport * from "./${paths.kebab}/${
    paths.kebab
  }";\n`;
  // Write the new barrel
  fs.writeFileSync(properBarrel, barrel, { encoding: "utf-8" });
}

/**
 * Create all the directories required for a component
 *
 * @param paths
 * @returns
 */
async function createDirectories(paths: ComponentPaths) {
  const componentPath = path.resolve(path.dirname(paths.component));
  const storiesPath = path.resolve(path.dirname(paths.stories));
  const dataPath = path.resolve(path.dirname(paths.data));

  try {
    await mkDir(componentPath);
    await mkDir(storiesPath);
    await mkDir(dataPath);
  } catch (error) {
    exitWarning(String(error));
  }
}

/**
 * Copy each of the component files to the destination project
 *
 * @param src
 * @param dst
 */
async function copyComponentFiles(src: ComponentPaths, dst: ComponentPaths) {
  // Fail if the core component is missing
  try {
    await copyFile(src.component, dst.component);
  } catch (error) {
    exitWarning(String(error));
  }

  // Proceed even if copying these files fail
  await copyFile(src.scss, dst.scss);
  await copyFile(src.stories, dst.stories);
  await copyFile(src.data, dst.data);
}

/**
 * COnfirm the action before copying the files and/or creating a new category.
 *
 * @param src
 * @param dst
 */
async function confirmAndCopy(src: ComponentPaths, dst: ComponentPaths) {
  // Confirm proceed
  const confirmProceed = await promptConfirm("Do you want to proceed?");

  if (confirmProceed) {
    // Create component directories
    await createDirectories(dst);

    // Update the barrel file
    await updateBarrel(dst);

    // Copy all component files
    await copyComponentFiles(src, dst);

    // Done
    process.stdout.write(`\n${chalk.greenBright("Done!")}\n`);
  }
}

/**
 * Do all the things
 */
export default async function run(
  source = "",
  component = "",
  ..._args: any[]
) {
  // Get paths for the destination project
  const dst = await checkStructure();

  // Get paths for the source project
  const src = await getSource(source, dst);

  // Get source component
  const srcComponent = await getSrcComponent(component, src);

  // Get destination component
  const destComponent = await getDestComponent(srcComponent, dst);

  // Confirm and do the deed
  await confirmAndCopy(srcComponent, destComponent);
}
