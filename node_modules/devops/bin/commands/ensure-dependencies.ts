import child_process from "child_process";
import fs from "fs-extra";
import inquirer from "inquirer";
import path from "path";
import { fuzzySource } from "../lib/util/fuzzy-source.js";
import { isPackageAvailable } from "../lib/util/is-package-available.js";
import { wait } from "../lib/util/wait.js";

export enum DependencyResolution {
  Install = "Install to current project",
  InstallOnce = "Install once to current project",
  InstallAbove = "Install in parent directory (Makes package available to all peer projects)",
  DoNothing = "Do Nothing (this will end this current process as the package is required)",
}

/**
 * This checks the target project for the presence of dependencies that are
 * required but are detrimental to experience and performance to include as a
 * dependency of the package directly.
 *
 * An example of such dependency would be puppeteer as having it can trigger
 * full installs and compilation of the dependency per project that needs it.
 *
 * So, this will request the dependency to be installed as a one time to the
 * current project or request to be installed above the target project to cause
 * it to be available to peer projects.
 */
export default async function run(
  dependencies?: string[],
  forceResolution?: DependencyResolution
) {
  const requiredDependencies = dependencies || ["puppeteer"];

  for (const dependency of requiredDependencies) {
    console.warn("Checking on dependency availability:", dependency);
    const isAvailable = await isPackageAvailable(dependency);

    if (!isAvailable) {
      let resolution = forceResolution;

      if (!resolution) {
        const result = await inquirer.prompt<{
          resolution: DependencyResolution;
        }>([
          {
            type: "autocomplete",
            name: "resolution",
            message: `How do you want to resolve the missing package "${dependency}":`,
            source: fuzzySource([
              DependencyResolution.InstallOnce,
              DependencyResolution.InstallAbove,
              DependencyResolution.DoNothing,
            ]),
          },
        ]);

        resolution = result.resolution;
      }

      switch (resolution) {
        case DependencyResolution.Install:
          child_process.execFileSync("npm", ["i", "-E", dependency], {
            stdio: "inherit",
          });
          break;

        case DependencyResolution.InstallOnce:
          child_process.execFileSync("npm", ["--no-save", "i", dependency], {
            stdio: "inherit",
          });
          break;

        case DependencyResolution.InstallAbove: {
          // Save the current cwd
          const cwd = process.cwd();
          // Change directory to the parent directory.
          process.chdir("..");

          // Check for a package.json
          if (!fs.existsSync(path.resolve("package.json"))) {
            // Perform an init to make the package
            child_process.execFileSync("npm", ["init", "--yes"], {
              stdio: "inherit",
            });
          }

          // Install the dependency
          child_process.execFileSync("npm", ["--no-save", "i", dependency], {
            stdio: "inherit",
          });
          // Return to original cwd
          process.chdir(cwd);
          // Perform an await to let file system flush
          await wait(100);
          break;
        }

        default:
          process.exit(1);
      }
    }
  }
}
