import { AI } from "./get-ai.js";
import { ChatCompletionRequestMessage } from "openai";

type Message =
  | ChatCompletionRequestMessage
  | ((previousAiResponse: string) => ChatCompletionRequestMessage | void);

export class DialogManager {
  private conversation: ChatCompletionRequestMessage[] = [];

  constructor(private ai: AI) {
    this.ai = ai;
  }
  /**
   * This function is used to converse with GPT. It takes a list of messages
   * or a mix of messages/callbacks and processes them in GPT.
   *
   * @param messages the list of messages or callbacks to send to gpt. Use a message to send a message.
   * Use a callback that returns a message if you want to save gpt's response in the conversation or you want to
   * use it in some way.
   * @param numberLatestAiResponsesToKeep the number of latest responses to keep from gpt
   */
  public async converse(
    messages: Message[],
    numberLatestAiResponsesToKeep: number | "all" = "all"
  ) {
    for await (const message of messages) {
      if (typeof message !== "function") {
        // just a message, doesn't require a response from gpt
        this.conversation.push({ ...message, content: message.content.trim() });
      } else {
        let aiResponse;
        let retries = 3;
        while (retries > 0) {
          try {
            aiResponse = await this.ai.getCode(this.conversation);
            break;
          } catch (error) {
            console.error(error);
            retries--;

            if (retries > 0) {
              console.error("Retrying...");
            }
          }
        }

        if (!aiResponse) {
          throw new Error("AI server error. See console for details.");
        }

        // push assistant response
        this.conversation.push({ role: "assistant", content: aiResponse });

        // filter out any non-recent assistant responses unless the user wants to keep all
        if (
          numberLatestAiResponsesToKeep !== "all" &&
          numberLatestAiResponsesToKeep > 0
        ) {
          this.conversation = this.filterLastAssistantCount(
            this.conversation,
            numberLatestAiResponsesToKeep
          );
        }

        // use callback to process the response and push user message
        const userMessage = message(aiResponse);

        if (userMessage) {
          this.conversation.push({
            ...userMessage,
            content: userMessage.content.trim(),
          });
        } else {
          break;
        }
      }
    }

    // if the last message is from the assistant, we don't need to send it to gpt
    if (this.conversation[this.conversation.length - 1].role === "assistant") {
      return {
        conversation: this.conversation,
        finalResponse: this.conversation[this.conversation.length - 1].content,
      };
    }

    // send the last message to gpt
    const finalResponse = await this.ai.getCode(this.conversation);
    this.conversation.push({ role: "assistant", content: finalResponse });

    return { finalResponse, convesation: this.conversation };
  }

  private filterLastAssistantCount(
    messages: ChatCompletionRequestMessage[],
    latestAiResponsesCount: number
  ): ChatCompletionRequestMessage[] {
    let assistantCount = 0;
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].role === "assistant") {
        assistantCount++;
        if (assistantCount > latestAiResponsesCount) {
          messages.splice(i, 1);
        }
      }
    }
    return messages;
  }

  public toString() {
    let result =
      "\n\n******************* Conversation Start *******************\n\n";
    result += this.conversation
      .map((m) =>
        `
=====${"=".repeat(m.role.length + 2)}=====
===== ${m.role.toLocaleUpperCase()} =====
=====${"=".repeat(m.role.length + 2)}=====

${m.content.trim()}`.trim()
      )
      .join("\n\n\n\n\n");
    result += "\n\n******************* Conversation End *******************";
    return result;
  }
}
