import fs from "fs-extra";
import path from "path";
import shell from "shelljs";
import { chalk } from "../util/chalk.js";
import { wait } from "../util/wait.js";
import { wordWrap } from "../util/word-wrap.js";

type PromptEvents = {
  /** Returns the saved information that came from the */
  onPrompt: (prompt: string) => Promise<void>;
  onExit: () => void;
};

type Dialog = (
  dialog: string,
  history?: { skipPrompt?: boolean; skipDialog?: boolean },
  halt?: boolean
) => Promise<void>;

/**
 * This generates an AI prompt window that is a new VS Code editor window. This
 * allows the prompt to be viewed while the component file is open in the
 * current window ctx.
 *
 * The ID should be unique to the window and context in any fashion so if we run
 * multiple contexts we don't overwrite each other.
 */
export async function promptWindow(
  id: string,
  events: PromptEvents
): Promise<Dialog> {
  // We will store this prompt window's file in the node_module's cache folder.
  const cachePath = path.resolve(
    __dirname,
    "../../../node_modules/.cache/__dev-ops__"
  );
  // We need to ensure the cache folder exists before we can create our prompt.
  fs.ensureDirSync(cachePath);
  // Get the path to our prompt file
  const filePath = path.resolve(cachePath, `${id}.prompt`);
  const historyPath = path.resolve(cachePath, `${id}.history`);

  // Create our file
  if (shell.touch(filePath).code !== 0) {
    throw new Error("Could not create prompt file for AI prompt interaction.");
  }

  // Ensure our file is empty
  fs.writeFileSync(filePath, "", { encoding: "utf8" });

  // Create a dialog history file so the user can monitor and utilize the
  // history of the discussion.
  if (shell.touch(historyPath).code !== 0) {
    throw new Error("Could not create history file for AI prompt interaction.");
  }

  // Wait a moment for the system command to flush out
  await wait(100);

  // We retain a closed flag as there is a tendency for closing the window to
  // execute one final stdout read out.
  const state = {
    closed: false,
    pause: false,
    skip: false,
  };

  // Start a tail on the file to watch for changes. We will run this async so we
  // don't lock up the file in any way
  const tailProcess = shell.exec(`tail -f ${filePath}`, {
    async: true,
    silent: true,
  });

  // Consistent exit handler to ensure all processes are stopped.
  const doExit = () => {
    if (!state.closed) {
      state.closed = true;
      events.onExit();
      tailProcess.kill();
    }
  };

  if (tailProcess && tailProcess.stdout) {
    tailProcess.stdout.on("data", () => {
      // Don't execute if the prompt window was closed already
      if (state.closed || state.pause) return;
      // We don't care about what data changed, we just care that the user saved
      // which caused a write to the prompt. We will consider save events to be
      // the trigger for processing a prompt. We will read the entire file and
      // send it to our event.
      const prompt = fs.readFileSync(filePath, { encoding: "utf8" });
      // Notify the caller that we have a prompt
      events.onPrompt(prompt);
    });

    tailProcess.on("error", (error) => {
      console.error(
        chalk.red(`Prompt tail process encountered an error:\n`),
        chalk.yellow(error.message)
      );
      doExit();
    });

    tailProcess.on("close", () => {
      // Notify the caller that we are exiting
      doExit();
    });
  } else {
    throw new Error("Could not start tail process for AI prompt interaction.");
  }

  // Open the prompt and history file in VS Code. We use the wait flag to make
  // the process not detach from the parent process allowing us to watch for it
  // to close.
  const windowProcess = shell.exec(`code -w -n ${filePath} ${historyPath}`, {
    async: true,
    silent: true,
  });

  if (windowProcess) {
    windowProcess.on("error", (error) => {
      console.error(
        chalk.red(`Prompt window process encountered an error:\n`),
        chalk.yellow(error.message)
      );
      doExit();
    });

    windowProcess.on("close", () => {
      doExit();
    });
  }

  // TODO: this attempts to ensure the prompt window is closed when this process
  // is finished. But it doesn't seem to work. We need to find a way to ensure
  // the prompt window is closed when the process is finished.
  async function closeWindow() {
    let resolve: Function;
    const complete = new Promise((r) => (resolve = r));

    // Run a PS command to find a PID with the proper args associated with it.
    // We know the args should include the path to the tail file which provides
    // plenty of specificity to ensure we are killing the correct process.
    const psCommand = `ps -ef | grep "${filePath}" | grep -v grep | awk '{print $2}'`;
    const psResult = shell.exec(psCommand, { silent: true, async: true });

    // If we have a process to watch, we will kill the processes found
    if (psResult && psResult.stdout) {
      let pidBuffer = "";

      psResult.stdout.on("data", (data) => {
        pidBuffer += data;
      });

      psResult.on("exit", () => {
        const pids = pidBuffer
          .split("\n")
          .map((p) => p.trim())
          .filter((p) => Boolean(p) && !isNaN(Number(p)));
        console.warn("Kill PIDs:", pids);

        if (pids.length > 0) {
          pids.forEach((pid) => {
            console.warn("Kill PID:", pid);
            shell.exec(`kill -9 ${pid}`);
          });
        }

        resolve();
      });
    }

    await complete;
  }

  async function handleExit() {
    console.warn("Exit Prompt");
    await closeWindow();
    doExit();
    tailProcess.kill();
    process.exit(0);
  }

  // Catch when app is closing
  process.on("exit", handleExit);
  // Catch ctrl+c event
  process.on("SIGINT", handleExit);
  // Catch "kill pid" (for example: nodemon restart)
  process.on("SIGUSR1", handleExit);
  process.on("SIGUSR2", handleExit);
  process.on("SIGTERM", handleExit);
  // Catch uncaught exceptions
  process.on("uncaughtException", handleExit);

  // We now return a method that will allow the caller to send a response to the
  // prompt. This will write the response to the prompt file and push the chat
  // history to the history file.
  // The caller of this Dialog can halt the events emitted to the onPrompt by
  // passing a promise that will resolve when the prompt can emit onPrompt
  // events again.
  // When skip history is true, the dialog will not be added to the history file.
  return async (
    dialog: string,
    history?: { skipPrompt?: boolean; skipDialog?: boolean },
    halt?: boolean
  ) => {
    // Pause the onPrompt events while modifying things automatically
    state.pause = true;
    let historyWrite = "";

    if (!history?.skipPrompt) {
      // Current contents of the prompt
      const promptContents = fs.readFileSync(filePath, { encoding: "utf8" });
      // Wait for flush
      await wait(100);
      historyWrite += `\n\n${wordWrap(promptContents, 80)}`;
    }

    if (!history?.skipDialog) {
      // Append the current prompt to the history file
      historyWrite += `\n\n${wordWrap(dialog, 80)}`;
    }

    if (historyWrite) {
      // Append the current prompt to the history file
      fs.appendFileSync(historyPath, historyWrite, { encoding: "utf8" });
      // Wait for flush
      await wait(100);
    }

    // Write the dialog as the prompt presented to the user
    fs.writeFileSync(filePath, wordWrap(dialog, 80), { encoding: "utf8" });
    // Wait for flush
    await wait(100);

    // Resume the onPrompt events if not requested to be halted
    if (!halt) state.pause = false;
  };
}
