let messages: ChatCompletionRequestMessage[] = [];
let latestCodeSnippet: ChatCompletionRequestMessage | undefined = undefined;
let latestPropsSnippet: ChatCompletionRequestMessage | undefined = undefined;
let latestStoriesSnippet: ChatCompletionRequestMessage | undefined = undefined;

const {
  newComponentTemplate,
  instructionsTemplate,
  newComponentTypesTemplate,
} = getTemplates(files);

messages = messages.filter((message) => message.role !== "assistant");

// only send latest assistant message
if (latestCodeSnippet) {
  messages.push(latestCodeSnippet);
}

// add user input
messages.push({
  role: "user",
  content: `
    ${instructionsTemplate.template}
    ${messages.length === 0 ? newComponentTemplate.template : ""}
    ${messages.length === 0 ? newComponentTypesTemplate.template : ""}
    Make these modifications:
    ${prompt}
  `.trim(),
});

console.log(messages);
// feed it to prompt
const assistantResponse = await ai.getCode([
  {
    role: "system",
    content: `
      You meticulously follow instructions.
      ${instructionsTemplate.template}
    `.trim(),
  },
  ...messages,
]);

// request props files based on the component file
const matchesForProps = parseGptCode(assistantResponse);
const props = await ai.getCode([
  ...(latestPropsSnippet ? [latestPropsSnippet] : []),
  {
    role: "user",
    content: template({
      doubleCurlyBrackets: true,
      template: fs.readFileSync(
        path.resolve(__dirname, "../lib/ai/new-component-props.prompt"),
        { encoding: "utf-8" }
      ),
      options: {
        prompt,
        fileName: paramCase(selections.name),
        componentName: pascalCase(selections.name),
        componentFileContent: matchesForProps.get("component"),
        componentTypesFileContent: matchesForProps.get("componentTypes"),
        componentPropsFileContent: matchesForProps.get("props"),
      },
    }).template,
  },
]);

// request stories files based on the component file
const matchesForStories = parseGptCode(props);
const stories = await ai.getCode([
  ...(latestStoriesSnippet ? [latestStoriesSnippet] : []),
  {
    role: "user",
    content: `Make sure to import { ${pascalCase(
      selections.name
    )}Props } from '../../data/${selections.directory}/${paramCase(
      selections.name
    )}-props';`,
  },
  {
    role: "user",
    content: template({
      doubleCurlyBrackets: true,
      template: fs.readFileSync(
        path.resolve(__dirname, "../lib/ai/new-component-stories.prompt"),
        { encoding: "utf-8" }
      ),
      options: {
        prompt,
        fileName: paramCase(selections.name),
        componentFileContent: matchesForProps.get("component"),
        componentTypesFileContent: matchesForProps.get("componentTypes"),
        componentPropsFileContent: matchesForStories.get("props"),
        componentSubdirectory: selections.directory,
      },
    }).template,
  },
  {
    role: "user",
    content: `Output exactly the same except without any unused imports.`,
  },
]);

latestCodeSnippet = {
  role: "assistant",
  content: assistantResponse,
};

latestPropsSnippet = {
  role: "assistant",
  // TODO: consider sending user's edits, rather than the assistant's response
  content: props,
};

latestStoriesSnippet = {
  role: "assistant",
  // TODO: consider sending user's edits, rather than the assistant's response
  content: stories,
};

writeResponseToFile(assistantResponse, files);
writeResponseToFile(props, files);
writeResponseToFile(stories, files);

// // verify imports in each file
// // const componentFileContent = matchesForProps.get('component');
// // const componentPropsFileContent = matchesForStories.get('props');
// const componentStoriesFileContent = parseGptCode(stories).get('story');

// try {
//   Promise.all([
//     verifyImports({
//       selections,
//       fileType: 'story',
//       fileContent: componentStoriesFileContent,
//       files
//     }),
//     // verifyImports({
//     //   selections,
//     //   fileType: 'component',
//     //   fileContent: componentFileContent,
//     //   files
//     // }),
//     // verifyImports({
//     //   selections,
//     //   fileType: 'props',
//     //   fileContent: componentPropsFileContent,
//     //   files
//     // })
//   ]);
// } catch (e) {
//   console.log(`Error verifying imports: ${e.message}`);
// }

function getTemplates(files: GeneratedFiles) {
  const fileName = path.basename(files.component).split(".")[0];
  const componentFileContent = fs.readFileSync(files.component, {
    encoding: "utf-8",
  });
  const componentTypesFileContent = fs.readFileSync(files.componentTypes, {
    encoding: "utf-8",
  });
  const componentScssFileContent = fs.readFileSync(files.scss, {
    encoding: "utf-8",
  });
  const componentStoryFileContent = fs.readFileSync(files.story, {
    encoding: "utf-8",
  });
  const componentPropsFileContent = fs.readFileSync(files.props, {
    encoding: "utf-8",
  });
  const newComponentTemplatePath = path.resolve(
    __dirname,
    "../lib/ai/new-component.prompt"
  );
  const instructionsTemplatePath = path.resolve(
    __dirname,
    "../lib/ai/instructions.prompt"
  );
  const newComponentTypesTemplatePath = path.resolve(
    __dirname,
    "../lib/ai/new-component-types.prompt"
  );
  const instructionsTemplate = template({
    doubleCurlyBrackets: true,
    template: fs.readFileSync(instructionsTemplatePath, {
      encoding: "utf-8",
    }),
    options: {
      fileName,
    },
  });
  const newComponentTemplate = template({
    doubleCurlyBrackets: true,
    template: fs.readFileSync(newComponentTemplatePath, {
      encoding: "utf-8",
    }),
    options: {
      fileName,
      componentFileContent,
      componentTypesFileContent,
      componentScssFileContent,
      componentStoryFileContent,
      componentPropsFileContent,
    },
  });

  const newComponentTypesTemplate = template({
    doubleCurlyBrackets: true,
    template: fs.readFileSync(newComponentTypesTemplatePath, {
      encoding: "utf-8",
    }),
    options: {
      fileName,
      componentFileContent,
      componentName: pascalCase(fileName),
    },
  });

  // Ensure all of the options within each template has been resolved
  if (
    newComponentTemplate.unresolvedTemplateOptions.size > 0 ||
    instructionsTemplate.unresolvedTemplateOptions.size > 0
  ) {
    console.warn("Failed to resolve all of a templates terms", {
      newComponentTemplate: newComponentTemplate.unresolvedTemplateOptions,
      instructionsTemplate,
    });
    process.exit(1);
  }

  return {
    instructionsTemplate,
    newComponentTemplate,
    newComponentTypesTemplate,
  };
}

// const verifyImports = async ({ selections, fileType, fileContent, files }: { selections: ComponentRequest, fileType: keyof GeneratedFiles, fileContent: string, files: GeneratedFiles }) => {
//   console.log(selections);
//   const getRelativePath = (filePath: string) => path.relative(path.resolve(), filePath)
//   console.log(fileType, chalk.red(fileContent));
//   const ai = await getAI();
//   if (!ai) {
//     return fileContent;
//   }

//   console.log(path.resolve(path.resolve(''), 'lib'));
//   // console.log(chalk.yellow(generateFileStructure(path.resolve(path.resolve(''), 'lib'))));
//   const pascalName = pascalCase(selections.name);
//   const filePath = getRelativePath(files[fileType]);
//   const componentPath = getRelativePath(files.component);
//   const componentPropsPath = getRelativePath(files.props);
//   const componentTypesPath = getRelativePath(files.componentTypes);
//   const componentStoryPath = getRelativePath(files.story);
//   const projectStructure = generateFileStructure(path.resolve(path.resolve(''), 'lib'));
//   console.log(projectStructure);
//   // const importValidationTemplate = template({
//   //   doubleCurlyBrackets: true,
//   //   template: fs.readFileSync(path.resolve(
//   //     __dirname,
//   //     "../lib/ai/import-validation.prompt"
//   //   ), { encoding: 'utf-8' }),
//   //   options: {
//   //     pascalName: pascalCase(selections.name),
//   //     filePath: getRelativePath(files[fileType]),
//   //     fileContent,
//   //     componentPath: getRelativePath(files.component),
//   //     componentPropsPath: getRelativePath(files.props),
//   //     componentTypesPath: getRelativePath(files.componentTypes),
//   //     componentStoryPath: getRelativePath(files.story),
//   //   }
//   // }).template.trim();

//   // console.log(chalk.grey(importValidationTemplate));

//   const correctedImports = await ai?.getCode([
//     {
//       role: 'user',
//       content: `
// Extract the imports from this file:
// \`\`\`
// ${fileContent}
// \`\`\`
//       `.trim()
//     },
//     {
//       role: 'user',
//       content: `
// Here's the project structure.

// File structure:
// \`\`\`
// ${projectStructure}
// \`\`\`
//       `.trim()
//     },
//     {
//       role: 'user',
//       content: `
// If the current file is located in \`${filePath}\`, correctly rewrite the imports relative to the current file without the file extension.

// The following are named exports:
// - \`${pascalName}\` should be imported from \`${componentPath}\`
// - \`${pascalName}\`Props should be imported from \`${componentPropsPath}\`
// - \`${pascalName}\`Mode should be imported from \`${componentTypesPath}\`
// - \`I${pascalName}\` should be imported from \`${componentTypesPath}\`
//       `.trim()
//     },
//     {
//       role: 'user',
//       content: `
// Remove any unused imports.
//       `.trim()
//     },
//     {
//       role: 'user',
//       content: `
// Place the imports in <geniantcode> tags.
// e.g.
// <geniantcode fileName="${path.basename(files[fileType])}">
// raw code
// </geniantcode>
//       `.trim()
//     }
//   ]);

//   console.log(chalk.grey(correctedImports));

//   writeResponseToFile(correctedImports, files);
// }
