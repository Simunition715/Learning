import fs from "fs";
import path from "path";

export type GeneratedFiles = {
  componentTypes: string;
  component: string;
  scss: string;
  story: string;
  props: string;
};

const getRelativePath = (filePath: string) =>
  path.relative(path.resolve(), filePath);

export const getGeneratedFiles = (
  files: GeneratedFiles
): {
  [key in keyof GeneratedFiles]: {
    absoluteFilePath: string;
    relativeFilePath: string;
    fileName: string;
    content: string;
  };
} => {
  return {
    component: {
      absoluteFilePath: files.component,
      relativeFilePath: getRelativePath(files.component),
      fileName: path.basename(files.component),
      content: fs.readFileSync(files.component, "utf8"),
    },
    componentTypes: {
      absoluteFilePath: files.componentTypes,
      relativeFilePath: getRelativePath(files.componentTypes),
      fileName: path.basename(files.componentTypes),
      content: fs.readFileSync(files.componentTypes, "utf8"),
    },
    scss: {
      absoluteFilePath: files.scss,
      relativeFilePath: getRelativePath(files.scss),
      fileName: path.basename(files.scss),
      content: fs.readFileSync(files.scss, "utf8"),
    },
    props: {
      absoluteFilePath: files.props,
      relativeFilePath: getRelativePath(files.props),
      fileName: path.basename(files.props),
      content: fs.readFileSync(files.props, "utf8"),
    },
    story: {
      absoluteFilePath: files.story,
      relativeFilePath: getRelativePath(files.story),
      fileName: path.basename(files.story),
      content: fs.readFileSync(files.story, "utf8"),
    },
  };
};

export const parseGptCode = (assistantResponse: string) => {
  const regex =
    /<geniantcode\s+fileName="([^"]+)"[^>]*>([\s\S]*?)<\/geniantcode>/gi;

  let match = null;
  const fileMap = new Map();

  while ((match = regex.exec(assistantResponse)) !== null) {
    const fileName = match[1];
    const content = match[2].trim();

    // write the content to the appropriate file
    if (fileName.endsWith(".scss")) {
      fileMap.set("scss", content);
    } else if (fileName.endsWith("-props.tsx")) {
      fileMap.set("props", content);
    } else if (fileName.endsWith(".stories.tsx")) {
      fileMap.set("story", content);
    } else if (fileName.endsWith(".tsx")) {
      fileMap.set("component", content);
    } else if (fileName.endsWith(".types.ts")) {
      fileMap.set("componentTypes", content);
    }
  }
  return fileMap;
};

export const generateFileStructure = (filePath: string, prefix = "") => {
  let fileStructure = "";

  try {
    // Get the stats of the current file path
    const stats = fs.lstatSync(filePath);

    // If the current path is a directory
    if (stats.isDirectory()) {
      // Get the list of items in the directory
      const items = fs.readdirSync(filePath);

      // Loop through each item
      items.forEach((item) => {
        const itemStats = fs.lstatSync(path.resolve(filePath, item));
        // Exclude node_modules and .git directories
        if (item !== "node_modules" && item !== ".git") {
          // Construct the tree-like structure with proper indentation
          fileStructure += `${prefix}${item}${
            itemStats.isDirectory() ? "/" : ""
          }\n`;
          // Recursively call the function on each item with updated prefix
          if (itemStats.isDirectory()) {
            fileStructure += generateFileStructure(
              path.join(filePath, item),
              `${prefix}  `
            );
          }
        }
      });
    }
    // If the current path is a file
    else if (stats.isFile()) {
      // Add the file name to the file structure with proper indentation
      fileStructure += `${prefix}${path.basename(filePath)}\n`;
    }
  } catch (error) {
    console.error(error);
  }

  return fileStructure;
};

export const writeGptCodeToFile = (
  assistantReponse: string,
  files: GeneratedFiles
) => {
  const gptCode = parseGptCode(assistantReponse);

  // for each available code block, write the content to the appropriate file
  gptCode.forEach((val, key) => {
    try {
      fs.writeFileSync(files[key as keyof GeneratedFiles], val, {
        encoding: "utf-8",
      });
    } catch (e) {
      console.error(e);
    }
  });
};
