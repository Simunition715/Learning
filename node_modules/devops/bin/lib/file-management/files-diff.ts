import fs from "fs-extra";
import path from "path";
import { aggregateFilePaths } from "./aggregate-file-paths.js";
import { gatherFilesAsObject } from "./gather-files-as-object.js";

export enum FileDiff {
  DELETE = "delete",
  CHANGE = "change",
  NEW = "new",
}

export enum FileType {
  FILE = "file",
  DIRECTORY = "directory",
  FILE_TO_DIRECTORY = "file-to-directory",
  DIRECTORY_TO_FILE = "directory-to-file",
}

/**
 * Returns all parent directories of a given path all the way up to the root of
 * the path.
 */
function getParentDirectories(check: string) {
  const out: string[] = [];
  let next = path.dirname(check);

  while (next && next !== "/" && next !== ".") {
    out.push(next);
    next = path.dirname(next);
  }

  return out;
}

/**
 * Checks two file paths and compares the path explicitly for a change. This
 * does NOT recurse through directories to see if the directory contents change,
 * rather this just sees if the qualities of the file at the given paths are
 * similar or not. This WILL check the contents of two compared FILES for a
 * change.
 */
function fileDiff(
  base1: string | undefined,
  f1: string,
  base2: string | undefined,
  f2: string
): [string, string, FileDiff, FileType] | null {
  const path1 = base1 ? path.resolve(base1, f1) : f1;
  const path2 = base2 ? path.resolve(base2, f2) : f2;

  if (fs.existsSync(path1) && !fs.existsSync(path2)) {
    return [
      path1,
      path2,
      FileDiff.NEW,
      fs.statSync(path1).isDirectory() ? FileType.DIRECTORY : FileType.FILE,
    ];
  }

  if (fs.existsSync(path2) && !fs.existsSync(path1)) {
    return [
      path1,
      path2,
      FileDiff.DELETE,
      fs.statSync(path2).isDirectory() ? FileType.DIRECTORY : FileType.FILE,
    ];
  }

  const f1IsDir = fs.statSync(path1).isDirectory();
  const f2IsDir = fs.statSync(path2).isDirectory();

  if (f1IsDir !== f2IsDir) {
    return [
      path1,
      path2,
      FileDiff.CHANGE,
      f1IsDir ? FileType.FILE_TO_DIRECTORY : FileType.DIRECTORY_TO_FILE,
    ];
  }

  // If both are directories, then the path is unchanged
  if (f1IsDir) return null;

  // Otherwise, both are files and should ahve their contents compared
  const f1Contents = fs.readFileSync(path1, "utf8");
  const f2Contents = fs.readFileSync(path2, "utf8");

  if (f1Contents !== f2Contents) {
    return [path1, path2, FileDiff.CHANGE, FileType.FILE];
  }

  // At this point, the files are determined to be the same
  return null;
}

/**
 * Examines two files or directories and returns a list of files that are
 * different between the two. Even if two files are tested, this will return a
 * that file in a list if it is different. This also tests if a file path is a
 * directory or a file and will detect they are different if one is a directory
 * and the other is a file.
 *
 * returns a list of [from, to, operation, to file type] tuples.
 *
 * If operation is "DELETE", then the file type indicates what TYPE of file is
 * being deleted. If the operation is "NEW", then the file type indicates what
 * TYPE of file is being created. If the operation is "CHANGE", then the file
 * type indicates what file type the target should be changed into.
 */
export async function filesDiff(
  base: string,
  target: string,
  out: [string, string, FileDiff, FileType][] = []
): Promise<[string, string, FileDiff, FileType][]> {
  try {
    const file1Pathing = gatherFilesAsObject(base);
    const file2Pathing = gatherFilesAsObject(target);

    const file1Paths = aggregateFilePaths(null, file1Pathing);
    const file2Paths = aggregateFilePaths(null, file2Pathing);
    const resolvedDirectories = new Set<string>();

    // If the base files are different types, then we just indicated that
    // EVERYTHING has changed which has some special case handling
    const diffBase = fileDiff(
      void 0,
      path.resolve(base),
      void 0,
      path.resolve(target)
    );

    if (diffBase) {
      switch (diffBase[2]) {
        // If the target is being deleted, then we loop through all file2Paths
        // and make diffs indicating each one is going to be removed. We delete
        // longest file paths to shortest file paths.
        case FileDiff.DELETE:
          out.push([
            path.resolve(base),
            path.resolve(target),
            FileDiff.DELETE,
            fs.statSync(path.resolve(target)).isDirectory()
              ? FileType.DIRECTORY
              : FileType.FILE,
          ]);
          return out;

        // If the target is being written to as completely new, then we loop
        // through all file1Paths and make diffs indicating each one is going
        // to be added. We add shortest file paths to longest file paths.
        case FileDiff.NEW:
          out.push([
            path.resolve(base),
            path.resolve(target),
            FileDiff.NEW,
            fs.statSync(path.resolve(base)).isDirectory()
              ? FileType.DIRECTORY
              : FileType.FILE,
          ]);
          return out;

        case FileDiff.CHANGE:
          // If the target is being changed from file to directory,
          // We flag the file for deletion, then we make new files for each file
          // coming from the target directory. Sorted shortest to longest paths.
          if (diffBase[3] === FileType.FILE_TO_DIRECTORY) {
            // Delete the existing target file
            out.push([
              path.resolve(base),
              path.resolve(target),
              FileDiff.DELETE,
              FileType.FILE,
            ]);
            // Add the target directory copy as last operation.
            out.push([
              path.resolve(base),
              path.resolve(target),
              FileDiff.NEW,
              FileType.DIRECTORY,
            ]);
          }

          // If the change is from directory to file, all the files within will
          // be deleted AND the target folder will be deleted too, THEN the
          // target will be replaced with a FILE
          else if (diffBase[3] === FileType.DIRECTORY_TO_FILE) {
            // Delete the target folder
            out.push([
              path.resolve(base),
              path.resolve(target),
              FileDiff.DELETE,
              FileType.DIRECTORY,
            ]);
            // Add the target file copy as last operation.
            out.push([
              path.resolve(base),
              path.resolve(target),
              FileDiff.NEW,
              FileType.FILE,
            ]);
          }

          // Otherwise, this is just a file's contents changing.
          else {
            out.push([
              path.resolve(base),
              path.resolve(target),
              FileDiff.CHANGE,
              FileType.FILE,
            ]);
          }
          return out;
      }
    }

    // Sort file paths shortest to longest so parents are resolved before
    // children
    file1Paths.sort((a, b) => a.length - b.length);

    // See which files do not exist in the target. This indicates a new file. If
    // the file exists in the target, this indicates a change.
    file1Paths.forEach((f1Path) => {
      // See what type of change has occurred between the two files.
      const diff = fileDiff(base, f1Path, target, f1Path);
      // If diff is null, no changed detected
      if (!diff) return;

      // See if the target is a descendent of a resolved directory. If so, we
      // skip it.
      const parentDirectories = getParentDirectories(diff[1]);
      const isResolved = parentDirectories.find((dir) =>
        resolvedDirectories.has(dir)
      );

      if (isResolved) return;

      switch (diff[2]) {
        // Target file should be deleted
        case FileDiff.DELETE:
          // If the target is a directory to be deleted, we specify the entrie
          // directory as resolved and add the removal to our diff list.
          if (diff[3] === FileType.DIRECTORY) {
            resolvedDirectories.add(diff[1]);
          }
          out.push(diff);
          return;

        case FileDiff.NEW:
          // If the target is a directory to be deleted, we specify the entrie
          // directory as resolved and add the removal to our diff list.
          if (diff[3] === FileType.DIRECTORY) {
            resolvedDirectories.add(diff[1]);
          }
          out.push(diff);
          return;

        case FileDiff.CHANGE:
          // Target is changing into a directory
          if (diff[3] === FileType.FILE_TO_DIRECTORY) {
            resolvedDirectories.add(diff[1]);
            // Delete the existing target file
            out.push([diff[0], diff[1], FileDiff.DELETE, FileType.FILE]);
            // Add the target directory copy as last operation.
            out.push([diff[0], diff[1], FileDiff.NEW, FileType.DIRECTORY]);
          }

          // Target is changing into a file
          else if (diff[3] === FileType.DIRECTORY_TO_FILE) {
            resolvedDirectories.add(diff[1]);
            // Delete the existing target directory
            out.push([diff[0], diff[1], FileDiff.DELETE, FileType.DIRECTORY]);
            // Add the target file copy as last operation.
            out.push([diff[0], diff[1], FileDiff.NEW, FileType.FILE]);
          }

          // File contents changed
          else {
            out.push(diff);
          }
          return;
      }
    });

    // Sort paths shortest to longest to resolve parents first
    file2Paths.sort((a, b) => a.length - b.length);

    // See which files are in the target but not in the base. This indicates a
    // file that was deleted.
    file2Paths.forEach((f2Path) => {
      // See what type of change has occurred between the two files.
      const diff = fileDiff(target, f2Path, base, f2Path);

      // In the reverse diff, We ONLY care about diffs that indicate a NEW file
      // or directory is created. This indicates the base no longer has that
      // file which would trigger a deletion to get the target to match the
      // base.
      if (!diff || diff[2] !== FileDiff.NEW) return;

      // Files with a resolved parent directory are skipped.
      const parentDirectories = getParentDirectories(diff[0]);

      const isResolved = parentDirectories.find((dir) =>
        resolvedDirectories.has(dir)
      );

      if (isResolved) return;

      if (diff[3] === FileType.DIRECTORY) {
        resolvedDirectories.add(diff[0]);
      }

      // Swap base and target from reverse diff to make the correct diff that
      // should be applied to the target to make the base match.
      out.push([diff[1], diff[0], FileDiff.DELETE, diff[3]]);
    });
  } catch (err) {
    console.error("Error comparing files", err);

    if (err instanceof Error) {
      console.error(err.stack || err.message || err);
    }

    return [];
  }

  return out;
}
