/**
 * A special type that allows deep nesting of identifiers before ultimately
 * landing on a specific type at the leaves of the object.
 */
export type Lookup<T> = { [key: string]: T | Lookup<T> };
/**
 * A special type that allows deep nesting of identifiers before ultimately
 * landing on a specific type at the leaves of the Map.
 */
export type LookupMap<T> = Map<string, T | LookupMap<T>>;

/**
 * Using a list of keys, this injects a value deeply into a Map object as a tree
 * structure.
 */
export function deepInjectMap<T>(
  key: string[],
  target: LookupMap<T>,
  value: T
): LookupMap<T> | null {
  const keys = key.slice(0);
  let parent = target;

  while (keys.length > 0) {
    const next = keys.shift();
    if (next === void 0) return null;

    if (keys.length === 0) {
      parent.set(next, value);
      return parent;
    }

    let map: LookupMap<T> | T | undefined = parent.get(next);

    if (!map || !(map instanceof Map)) {
      map = new Map<string, T>();
      parent.set(next, map);
      parent = map;
    } else {
      parent = map;
    }
  }

  return null;
}

/**
 * Using a list of keys, this retrieves a value deeply from a Map object that
 * has a tree structure.
 */
export function deepGet<T>(
  key: string[],
  target: LookupMap<T>
): LookupMap<T> | T | undefined {
  const keys = key.slice(0);
  let parent = target;

  while (keys.length > 0) {
    const next = keys.shift();
    if (next === void 0) return;

    const map: LookupMap<T> | T | undefined = parent.get(next);
    // If we're at the exact key, return whatever is present.
    if (keys.length === 0) return map;

    // We are continuing and need to keep going if we found another map object
    // and we still have keys available
    if (map instanceof Map) {
      parent = map;
    }

    // If there is nothing left to traverse but we have more keys, return
    // nothing found.
    else {
      return;
    }
  }

  return;
}

export type LookupNode<T> = {
  id: string[];
  data: T[];
  children: LookupNode<T>[];
};

/**
 * Flattened node structure. This provides some indexing numbers to aid in
 * looping through the flatened structure.
 *
 * next sibling and parent index is -1 when there is no sibling or parent.
 *
 * [depth, node, parent index, next sibling]
 */
export type FlattenedLookupNode<T> = [
  number,
  T | LookupNode<T>,
  number,
  number,
][];

/**
 * Converts a Map tree structure into Nodes.
 *
 * TODO: don't use recursion. This is the quick way to implement. This will
 * crash on circular map dependency.
 */
export function mapToNodes<T extends { nodeId?: string[] }>(
  map: LookupMap<T>,
  nodeComplete?: (node: LookupNode<T>) => void,
  id?: string[]
): LookupNode<T> {
  const nodeId = id || [];

  const node: LookupNode<T> = {
    id: nodeId,
    data: [],
    children: [],
  };

  map.forEach((value, key) => {
    const newId = nodeId.concat(key);

    if (value instanceof Map) {
      node.children.push(mapToNodes(value, nodeComplete, newId.slice(0)));
    } else {
      value.nodeId = newId.slice(0);
      node.data.push(value);
    }
  });

  nodeComplete?.(node);
  return node;
}

/**
 * Flattens a LookupNode to a simple list with
 */
export function flattenNodeData<T>(
  node: LookupNode<T>,
  depth = 0,
  parentIndex = -1,
  out: FlattenedLookupNode<T> = []
): FlattenedLookupNode<T> {
  const pIndex = out.length;
  const thisNode: FlattenedLookupNode<T>[0] = [depth, node, parentIndex, -1];
  out.push(thisNode);

  // List the node's data directly first. Each sibling's index is simply the
  // current
  node.data.forEach((value) =>
    out.push([depth + 1, value, pIndex, out.length + 1])
  );

  // Next list the children and their data next
  node.children.forEach((child) => {
    const nextNodeIndex = out.length;
    flattenNodeData(child, depth + 1, pIndex, out);
    out[nextNodeIndex][3] = out.length;
  });

  // Final child gets it's sibling flagged as no sibling with -1
  out[out.length - 1][3] = -1;

  return out;
}

/**
 * Converts an object Lookup to a LookupMap
 *
 * TODO: Don't use recursion
 */
export function makeLookupMap<T>(
  lookup: Lookup<T>,
  typeGuard: (value: any) => value is T
): LookupMap<T> {
  const map: LookupMap<T> = new Map();

  Object.keys(lookup).forEach((key) => {
    const value = lookup[key];

    if (typeGuard(value)) {
      map.set(key, value);
    } else {
      map.set(key, makeLookupMap(value, typeGuard));
    }
  });

  return map;
}

/**
 * A very tricky method that maps a Lookup (dictionary with nested keys) to
 * values found in the leaves of the tree of the object.
 */
export function mapLookupValues<T, U>(
  label: string,
  typeGuard: (value: T | Lookup<T>) => value is T,
  lookup: Lookup<T>,
  callback: (key: string[], value: T) => U
): U[] {
  const added = new Set();
  const out: U[] = [];
  const toProcess = Object.keys(lookup).map<[string[], T | Lookup<T>]>(
    (key) => [[key], lookup[key]]
  );

  for (let index = 0; index < toProcess.length; ++index) {
    const next = toProcess[index];
    const nextValue = next[1];

    if (typeGuard(nextValue)) {
      out.push(callback(next[0], nextValue));
    } else {
      let error = false;
      const nextChunk: [string[], T | Lookup<T>][] = [];

      Object.keys(nextValue).forEach((key) => {
        const value = nextValue[key];

        if (!added.has(value)) {
          nextChunk.push([next[0].concat(key), value]);
          added.add(value);
        } else {
          error = true;
          console.warn(
            "Invalid lookup for mapping Lookup values detected:",
            label
          );
        }
      });

      // Inject the next chunk of items at the place of the current process item
      // So we retain the tree order that items appear in
      if (nextChunk.length > 0) {
        toProcess.splice(index + 1, 0, ...nextChunk);
      }

      if (error) break;
    }
  }

  return out;
}
