#!/usr/bin/env ts-node
import * as commander from "commander";
import AutoCompletePrompt from "inquirer-autocomplete-prompt";
import ensureDependencies from "./commands/ensure-dependencies.js";
import fs from "fs";
import inquirer from "inquirer";
import path from "path";
import shell from "shelljs";
import yargs from "yargs";
import { chalk } from "./lib/util/chalk.js";
import { description } from "./lib/util/description.js";
import { dotenv } from "./lib/util/dot-env.js";

inquirer.registerPrompt("autocomplete", AutoCompletePrompt);

if (fs.existsSync(path.resolve(".env"))) {
  dotenv();
}

const { Command } = commander;
const program: any = new Command();
const options: Record<string, any> = {};

function getOptions() {
  options.debug = program.debug;
  options.verbose = program.verbose;
  options.pattern = program.pattern;

  return options;
}

program.version("0.0.1");
program.option(
  "-v, --verbose",
  "Outputs more detailed information during crashes."
);
program.option(
  "--debug [param]",
  description`
    Provides debugging contextual information various commands might use to
    aid in developing Devops.
  `
);

program.option(
  "-p, --pattern [param]",
  description`
    Provides a pattern for certain operations to utilize. This is primarily
    used by unit tests to filter tests to specified tests.
  `
);

const dev = program.command("dev").description(
  description`
    These are the commands associated with starting up developer environments
    for various project types or portions of a project.
  `
);

dev
  .command("vite")
  .description(
    description`
      Starts up a developer environment that performs incremental builds while
      developing within the lib and app folders. Uses vite and vite
      config.
    `
  )
  .action(async () => {
    (await import("./commands/dev-vite.js")).default().catch((err: Error) => {
      console.warn("dev-vite process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

const devNative = dev.command("native").description(
  description`
      Starts up a developer environment that runs on native platforms such as
      mobile.
    `
);

devNative
  .command("ios")
  .description(
    description`
    Starts up a developer environment for developing on iOS. This utilizes the
    capacitor platform to make the web application run on the mobile platform.
  `
  )
  .action(async () => {
    (await import("./commands/dev-native-ios.js"))
      .default()
      .catch((err: Error) => {
        console.warn("dev-native process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

devNative
  .command("android")
  .description(
    description`
    Starts up a developer environment for developing on iOS. This utilizes the
    capacitor platform to make the web application run on the mobile platform.
  `
  )
  .action(async () => {
    (await import("./commands/dev-native-android.js"))
      .default()
      .catch((err: Error) => {
        console.warn("dev-native process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

dev
  .command("storybook")
  .option(
    "-i, --include <include...>",
    "Additional storybook modules to load into storybook. These are the names of properly formatted dependencies installed into node_modules."
  )
  .description(
    description`
      Starts a storybook instance for developing the UI components of the
      project. This makes the "ui/stories" folder in the project the expected
      development point.
    `
  )
  .action(async ({ include }: { include: string[] }) => {
    (await import("./commands/storybook.js"))
      .default("", include, path.resolve(process.cwd()), getOptions())
      .catch((err: Error) => {
        console.warn("storybook process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

const storybook = program.command("storybook");

storybook
  .command("run")
  .option(
    "-i, --include <include...>",
    "Additional storybook modules to load into storybook. These are the names of properly formatted dependencies installed into node_modules."
  )
  .description(
    description`
      Starts a storybook instance for developing the UI components of the
      project. This makes the "ui/stories" folder in the project the expected
      development point.
    `
  )
  .action(async ({ include }: { include: string[] }) => {
    (await import("./commands/storybook.js"))
      .default("", include, path.resolve(process.cwd()), getOptions())
      .catch((err: Error) => {
        console.warn("storybook process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

storybook
  .command("build")
  .option(
    "-i, --include <include...>",
    description`
      Additional storybook modules to load into storybook. These are the names
      of properly formatted dependencies installed into node_modules.
    `
  )
  .description(
    description`
      Generates the static storybook files so the storybook can be hosted
    `
  )
  .action(async ({ include }: { include: string[] }) => {
    (await import("./commands/storybook.js"))
      .default("build", include, path.resolve(process.cwd()), getOptions())
      .catch((err: Error) => {
        console.warn("storybook process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

program
  .command("url [uri...]")
  .description(
    description`
      Simple command to open a specified URL in the browser.
    `
  )
  .action(async (uri: string) => {
    (await import("./commands/url.js")).default(uri).catch((err: Error) => {
      console.warn("url process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

const release = program.command("release").description(
  description`
    These commands are used for facilitating distribution releases of
    applications. This includes tools for building th dist folder fragments,
    viewing the expected release notes, and actually performing a complete
    release cycle.
  `
);

release
  .command("deploy [add-remote...]")
  .description(
    description`
      Performs actions necessary to update the distribution of the project.
      This will automatically update release notes, tag the release, and
      commit and push to a 'release' branch which will be ready for merging
      into master and dev.

      Specify additional remotes to deploy to via the add-remote option.
      This will deploy the release to additional remotes (AFTER all other normal
      deploy operations complete). This value is the NAME of the remote as it
      appears when you perform a "git remote -v" command.

      You can specify a specific target branch via a colon: remote:branch
      Otherwise, this will use the same main branch as configured for this
      project.
    `
  )
  .action(async (remotes: string[]) => {
    // Before starting the release script make sure our packages are up to date to the latest
    shell.exec("npm i");
    (await import("./commands/release-deploy.js"))
      .default(remotes)
      .catch((err: Error) => {
        console.warn(
          "release-deploy process exited unexpectedly\n",
          err.stack || err.message
        );
        process.exit(1);
      });
  });

release
  .command("types")
  .description(
    description`
      Updates JUST the types in the dist folder. These are the same types
      generated when building a release.
    `
  )
  .action(async () => {
    // Before starting the release script make sure our packages are up to date to the latest
    (await import("./commands/release-types.js"))
      .default()
      .catch((err: Error) => {
        console.warn(
          "release-types process exited unexpectedly\n",
          err.stack || err.message
        );
        process.exit(1);
      });
  });

release
  .command("view")
  .description(
    description`
      This runs the release-view script. For this case, it will only display
      the release notes in the console. Actual generated release notes are a
      part of the release process.
    `
  )
  .action(async () => {
    (await import("./commands/ts.js"))
      .default("")
      .then(async () => {
        console.warn(
          chalk.cyanBrightBold("TS check passed, generating notes...")
        );
        // Before starting the release script make sure our packages are up to date to the latest
        (await import("./commands/release-view.js"))
          .default()
          .catch((err: Error) => {
            console.warn(
              "release-notes process exited unexpectedly",
              err.stack || err.message
            );
            process.exit(1);
          });
      })
      .catch((err: Error) => {
        console.warn(
          chalk.redBrightBold(
            description`
              Failed TS check. Release notes will not be produced until all TS
              errors are resolved.
            `
          )
        );
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

release
  .command("build")
  .description(
    description`
      This runs the release-build script. This generates all of the release
      fragments. This should ONLY be used for testing and experimenting. Actual
      release fragments should be properly created and deployed using the
      release deploy command.
    `
  )
  .action(async () => {
    (await import("./commands/release-build.js"))
      .default()
      .catch((err: Error) => {
        console.warn(
          "release-deploy process exited unexpectedly\n",
          err.stack || err.message
        );
        process.exit(1);
      });
  });

const releaseStart = release.command("start").description(
  description`
      This starts up released related processes. This includes things like
      starting up the dev server without any additional builds or auto
      configuration for development.
    `
);

releaseStart
  .command("server")
  .description(
    description`
      Starts up the app server without any additional builds etc. Use the
      environments:

        BUILD_MODE: Targets an env to run the server for.
        RESOURCE_PATH: The path to the static files to serve.
    `
  )
  .action(async () => {
    (await import("./commands/release-start-server.js"))
      .default()
      .catch((err: Error) => {
        console.warn(
          "release-start-server process exited unexpectedly\n",
          err.stack || err.message
        );
        process.exit(1);
      });
  });

const releaseHeroku = release.command("heroku").description(
  description`
      These are different release strategies to deploy to a heroku node. These
      can include storybook or web app deploys.
    `
);

releaseHeroku
  .command("storybook")
  .description(
    description`
      Deploys the static storybook build artifacts to a heroku instance.
    `
  )
  .action(async () => {
    (await import("./commands/release-heroku-storybook.js"))
      .default()
      .catch((err: Error) => {
        console.warn(
          "release-heroku-storybook process exited unexpectedly",
          err.stack || err.message
        );
        process.exit(1);
      });
  });

program
  .command("start [target]")
  .description(
    description`
      This fires up a server to make any static content available for being
      served.
      There are a few options for what content will be served by this script:

      - The web app
      - Devops API

      The start script will automatically pick the web app over the devops
      files, but you can specify a target if you have a devops API and a web
      app:

      - app
      - devops
    `
  )
  .action(async (target: string) => {
    (await import("./commands/start.js"))
      .default(target, getOptions())
      .catch((err: Error) => {
        console.warn("start process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

const test = program.command("test").description(
  description`
    These commands are used for running tests. This includes tools for
    running unit tests a single time or in a watch mode.
  `
);

test
  .command("run")
  .description(
    description`
      Runs all unit tests in the unit-test folder once.
    `
  )
  .action(async () => {
    (await import("./commands/test-run.js")).default().catch((err: Error) => {
      console.warn("test-run process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

test
  .command("dev")
  .description(
    description`
      Starts up the unit tests in the unit-test folder. This also re-runs the
      tests automatically when changes are made to the tests or to the source code.
    `
  )
  .action(async () => {
    (await import("./commands/test-dev.js")).default().catch((err: Error) => {
      console.warn("test-dev process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

test
  .command("debug")
  .description(
    description`
      This is the same as unit-test-dev, EXCEPT this will cause the process to
      halt and wait for a debugger to be attached before continuing. You can use
      the Chrome url: chrome://inspect/#devices to easily attach a chrome
      debugger when this is used.
    `
  )
  .action(async () => {
    (await import("./commands/test-debug.js")).default().catch((err: Error) => {
      console.warn("test-debug process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

const clean = program.command("clean").description(
  description`
    Common cleaning tools for various fragments within the project.
  `
);

clean
  .command("dts")
  .description(
    description`
      Sometimes fiddling around with build systems with typescript, you can mess
      up. You will know you messed up, because .d.ts files will show up next to
      ALL of your source code. This helps you clean up your shame without
      leaving a trace.
    `
  )
  .action(async () => {
    (await import("./commands/clean-dts.js")).default().catch((err: Error) => {
      console.warn("clean-dts process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

clean
  .command("cache")
  .description(
    description`
      Cleans out build and cache files to help ensure a complete rebuild takes
      place.
    `
  )
  .action(async () => {
    (await import("./commands/clean-cache.js"))
      .default()
      .catch((err: Error) => {
        console.warn("clean-cache process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

const ts = program.command("ts").description(
  description`
    These commands are used for running typescript. This includes tools for
    running typescript compilation a single time or in a watch mode.
  `
);

ts.command("run")
  .description(
    description`
      Runs typescript compilation to check for errors. Does NOT emit files, thus
      is a good mechanism for checking a build before running a release.
    `
  )
  .action(async () => {
    (await import("./commands/ts.js")).default("").catch((err: Error) => {
      console.warn("ts process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

ts.command("watch")
  .description(
    description`
      Runs typescript compilation to check for errors. Does NOT emit files, and
      executes in a watch mode that waits for changes.
    `
  )
  .action(async () => {
    (await import("./commands/ts.js")).default("watch").catch((err: Error) => {
      console.warn("ts process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

const ticket = program.command("ticket");

ticket
  .command("new [url] [name]")
  .description(
    description`
      Creates a branch and sets up development against a specified ticket URL.

      Creating the ticket branch using this method will ensure the branch can
      quickly navigate to the associated ticket.
    `
  )
  .action(async (url: string, name: string) => {
    (await import("./commands/ticket-new.js"))
      .default(url, name)
      .catch((err: Error) => {
        console.warn("ticket-new process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

ticket
  .command("view")
  .description(
    description`
      This command only works if you are on a ticket branch that was created via
      the ticket command. It will open the URL for the ticket in your default
      browser.
    `
  )
  .action(async () => {
    (await import("./commands/ticket-view.js"))
      .default()
      .catch((err: Error) => {
        console.warn("ticket-view process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

const pr = program
  .command("pr")
  .option(
    "--repoUrl <value>",
    description`
      The https URL to the repo to make the PR into
    `
  )
  .option(
    "--repoType <value>",
    description`
    The repository type to make the PR into. Supported types are: git, gitlab
  `
  )
  .option(
    "--masterBranch <value>",
    description`
    This indicates which branch is the master/main of the repository.
  `
  );

pr.command("ticket")
  .description(
    description`
      This command only works if you are on a ticket branch that was created via
      the ticket command. It will open the URL for the ticket in your default
      browser.
    `
  )
  .action(async () => {
    const { repoUrl, repoType } = yargs(process.argv).argv as {
      repoType?: string;
      repoUrl?: string;
    };

    if (!repoUrl || !repoType) {
      console.warn(
        "You must specify both --repoUrl and --repoType to use this command"
      );
      process.exit(1);
    }

    // Make sure we have any required peer dependencies for this
    await ensureDependencies().catch(() => process.exit(1));

    (await import("./commands/pr-ticket.js"))
      .default(repoUrl, repoType)
      .catch((err: Error) => {
        console.warn("pr-ticket process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

pr.command("release")
  .description(
    description`
      This creates two PRs that merges the current remote release branch into
      the remote dev and master branches.
    `
  )
  .action(async () => {
    const { repoUrl, repoType, masterBranch } = yargs(process.argv).argv as {
      repoType?: string;
      repoUrl?: string;
      masterBranch?: string;
    };

    if (!repoUrl || !repoType || !masterBranch) {
      console.warn(
        "You must specify both --repoUrl and --repoType to use this command"
      );
      process.exit(1);
    }

    // Make sure we have any required peer dependencies for this
    await ensureDependencies().catch(() => process.exit(1));

    (await import("./commands/pr-release.js"))
      .default(repoUrl, repoType, masterBranch)
      .catch((err: Error) => {
        console.warn("pr-release process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

program
  .command("fix-mac-firewall")
  .description(
    description`
      While developing (especially with the npm module 'n') you will get caught
      into a mac system loop where every build will cause an "accept incoming
      network" prompt. Running this should fix the issue (you may see the prompt
      one more time).
    `
  )
  .action(async () => {
    (await import("./commands/fix-mac-firewall.js"))
      .default()
      .catch((err: Error) => {
        console.warn("fix-mac-firewall process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

program
  .command("skeleton")
  .description(
    description`
      This converts a project that is a skeleton project into a new project with
      specific configuration fields getting populated for the new project. This
      also establishes the project under a new repository effectively breaking
      the skeleton project from it's source repo.
    `
  )
  .action(async () => {
    (await import("./commands/skeleton.js"))
      .default(getOptions())
      .catch((err: Error) => {
        console.warn("skeleton process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

const component = program.command("component").description(
  description`
    These commands are used for managing components in the UI library. Anywhere
    the [name...] is an option means you can type the component name in ANY case
    type and the system will identify the correct component files associated
    with that specified name.
  `
);

component
  .command("story [name...]")
  .description(
    description`
      Adds a new story to an existing component. This will append a new story to
      it's base story file and will add an action to the data store.
    `
  )
  .action(async (name: string[]) => {
    (await import("./commands/component-story.js"))
      .default(name.join(" "))
      .catch((err: Error) => {
        console.warn("component-story process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

component
  .command("new [name...]")
  .description(
    description`
      Performs all of the steps necessary to create a new library component.
      This includes creating the component and all of the test files/fragments
      needed to make the component show up in storybook.

      Provide a name as the last argument if you wish to bypass the prompts
      asking for one.
    `
  )
  .action(async (name: string[]) => {
    (await import("./commands/component-new.js"))
      .default(name.join(" "), getOptions())
      .catch((err: Error) => {
        console.warn("component-new process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

component
  .command("edit [name...]")
  .description(
    description`
      Performs all of the steps necessary to create a new library component.
      This includes creating the component and all of the test files/fragments
      needed to make the component show up in storybook.\n

      Provide a name as the last argument if you wish to bypass the prompts
      asking for one.
    `
  )
  .action(async (name: string[]) => {
    (await import("./commands/component-edit.js"))
      .run(name.join(" "), getOptions())
      .catch((err: Error) => {
        console.warn("component-edit process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

component
  .command("delete [name...]")
  .description(
    description`
      Performs all of the steps necessary to delete a library component. This
      includes deleting the component and all of its associated test
      files/fragments.

      Provide a name as the last argument if you wish to bypass the prompts
      asking for one.
    `
  )
  .action(async (name: string[]) => {
    (await import("./commands/component-delete.js"))
      .default(name.join(" "), getOptions())
      .catch((err: Error) => {
        console.warn("component-delete process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

component
  .command("rename [name...]")
  .description(
    description`
      Performs all the steps necessary to rename a library component. This
      includes renaming the component and all of its associated test
      files/fragments.

      Provide a name as the last argument if you wish to bypass the prompts
      asking for one.
    `
  )
  .action(async (name: string[]) => {
    (await import("./commands/component-rename.js"))
      .default(name.join(" "), getOptions())
      .catch((err: Error) => {
        console.warn("component-rename process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

component
  .command("copy [source] [component]")
  .description(
    description`
      Performs all the steps necessary to copy a library component from one
      project to another project. This includes copying the component and
      all of its associated test files/fragments.
    `
  )
  .action(async (source = "", component = "") => {
    (await import("./commands/component-copy.js"))
      .default(source, component, getOptions())
      .catch((err: Error) => {
        console.warn("component-copy process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

const runInitConfig = async () => {
  (await import("./commands/init.js")).default().catch((err: Error) => {
    console.warn("init process exited unexpectedly");
    console.warn(err.stack || err.message);
    process.exit(1);
  });
};

const init = program.command("init").description(
  description`
    Init commands intiialize a suite of configurations or empty template
    structures that devops expects to have to work for certain tools.
  `
);

init
  .command("project")
  .description(
    description`
      This copies all of the configuration files that should be in the root of
      the project to enable correct tooling and feedback to occur. Run update to
      get the latest configurations from devops.
    `
  )
  .action(runInitConfig);

init
  .command("app")
  .description(
    description`
    Initializes the presence of an app folder for your target project. This will
    establish the base empty files needed for a node app to be created and
    recognized by this devops system.
    `
  )
  .action(async () => {
    (await import("./commands/init-app.js")).default().catch((err: Error) => {
      console.warn("init-app process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

init
  .command("ui")
  .description(
    description`
    Initializes the presence of a UI library for your target project. This will
    establish the base empty files needed for a ui library to be created and
    recognized by this devops system.
    `
  )
  .action(async () => {
    (await import("./commands/init-ui.js")).default().catch((err: Error) => {
      console.warn("init-ui process exited unexpectedly");
      console.warn(err.stack || err.message);
      process.exit(1);
    });
  });

init
  .command("native")
  .description(
    description`
    Initializes the presence of a Native project that allows the project to run
    and compile on a native platforms utilizing React-Native.
    `
  )
  .action(async () => {
    (await import("./commands/init-native.js"))
      .default()
      .catch((err: Error) => {
        console.warn("init-native process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

init
  .command("unit-test")
  .description(
    description`
    Initializes the presence of a unit-test folder that works with this devops
    system. This provides a basic setup and example of how tests are written.
    `
  )
  .action(async () => {
    (await import("./commands/init-unit-test.js"))
      .default()
      .catch((err: Error) => {
        console.warn("init-unit-test process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

program
  .command("update")
  .description(
    description`
      Updates your current project to the latest provided configuration files
      that devops has available.
    `
  )
  .action(runInitConfig);

const native = program.command("native").description(
  description`
    These commands are used for managing native projects. This includes tools
    for running native applications in development mode, building native
    applications for distribution, and managing the native project.
  `
);

native
  .command("ios-check")
  .description(
    description`
      This command examines the developer's system to see if it is ready for
      native development with React Native for iOS applications.
    `
  )
  .action(async () => {
    (await import("./commands/native-ios-check.js"))
      .default()
      .catch((err: Error) => {
        console.warn("native-ios-check process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

/**
 * Test a specific command file with params
 */
program
  .command("try [file] [params...]")
  .description(
    description`
    Try a specific command
  `
  )
  .action(async (file = "", params?: string[]) => {
    (await import("./commands/try.js"))
      .default(file, params)
      .catch((err: Error) => {
        console.warn("try process exited unexpectedly");
        console.warn(err.stack || err.message);
        process.exit(1);
      });
  });

program.parse(process.argv);
